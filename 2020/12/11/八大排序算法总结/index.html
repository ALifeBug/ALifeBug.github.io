<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>八大排序算法总结 | ALifeBug</title><meta name="description" content="八大排序算法总结"><meta name="keywords" content="算法,排序"><meta name="author" content="Huang Qingshan"><meta name="copyright" content="Huang Qingshan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://alifebug.github.io/2020/12/11/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="八大排序算法总结"><meta name="twitter:description" content="八大排序算法总结"><meta name="twitter:image" content="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><meta property="og:type" content="article"><meta property="og:title" content="八大排序算法总结"><meta property="og:url" content="http://alifebug.github.io/2020/12/11/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="ALifeBug"><meta property="og:description" content="八大排序算法总结"><meta property="og:image" content="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="kafka多线程消费保证跨区消费顺序一致性的研究" href="http://alifebug.github.io/2020/12/11/kafka%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B6%88%E8%B4%B9%E4%BF%9D%E8%AF%81%E8%B7%A8%E5%8C%BA%E6%B6%88%E8%B4%B9%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E7%A0%94%E7%A9%B6/"><link rel="next" title="Java内部类详解" href="http://alifebug.github.io/2020/12/11/Java%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">ALifeBug</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">61</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">44</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">24</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#八大排序算法总结"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">八大排序算法总结</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#算法一：插入排序"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">算法一：插入排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#算法二：希尔排序"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">算法二：希尔排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#算法三：选择排序"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">算法三：选择排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#算法四：冒泡排序"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">算法四：冒泡排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#算法五：归并排序"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">算法五：归并排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#算法六：快速排序"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">算法六：快速排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#算法七：堆排序"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">算法七：堆排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#算法八：基数排序"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">算法八：基数排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#八大排序算法总结"><span class="toc-number">1.</span> <span class="toc-text">八大排序算法总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#算法一：插入排序"><span class="toc-number">1.1.</span> <span class="toc-text">算法一：插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法二：希尔排序"><span class="toc-number">1.2.</span> <span class="toc-text">算法二：希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法三：选择排序"><span class="toc-number">1.3.</span> <span class="toc-text">算法三：选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法四：冒泡排序"><span class="toc-number">1.4.</span> <span class="toc-text">算法四：冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法五：归并排序"><span class="toc-number">1.5.</span> <span class="toc-text">算法五：归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法六：快速排序"><span class="toc-number">1.6.</span> <span class="toc-text">算法六：快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法七：堆排序"><span class="toc-number">1.7.</span> <span class="toc-text">算法七：堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法八：基数排序"><span class="toc-number">1.8.</span> <span class="toc-text">算法八：基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.9.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">八大排序算法总结</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-12-11<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-12-11</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><div class="post-meta-wordcount"><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="八大排序算法总结"><a href="#八大排序算法总结" class="headerlink" title="八大排序算法总结"></a><a href="https://www.cnblogs.com/RainyBear/p/5258483.html" target="_blank" rel="noopener">八大排序算法总结</a></h1><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p>
<p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p>
<p>本文将依次介绍上述八大排序算法。</p>
<h2 id="算法一：插入排序"><a href="#算法一：插入排序" class="headerlink" title="算法一：插入排序"></a>算法一：插入排序</h2><p><img alt="img" data-src="https://img2018.cnblogs.com/blog/897388/201910/897388-20191011100656819-1756329295.gif" class="lozad"></p>
<p>插入排序示意图</p>
<p>插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p><strong>算法步骤：</strong></p>
<p>1）将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
<p>2）从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> array[],unsignedint n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i < n;i++)</span><br><span class="line">    {</span><br><span class="line">        temp = array[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i;j > <span class="number">0</span>&& array[j - <span class="number">1</span>] > temp;j--)</span><br><span class="line">        {</span><br><span class="line">            array[j]= array[j - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="算法二：希尔排序"><a href="#算法二：希尔排序" class="headerlink" title="算法二：希尔排序"></a>算法二：希尔排序</h2><p><img alt="img" data-src="https://img2018.cnblogs.com/blog/897388/201910/897388-20191011100713592-1947775907.gif" class="lozad"></p>
<p>希尔排序示意图</p>
<p><strong>希尔排序</strong>，也称<strong>递减增量排序算法</strong>，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到<a href="http://zh.wikipedia.org/w/index.php?title=%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F&action=edit&redlink=1" target="_blank" rel="noopener">线性排序</a>的效率</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p><strong>算法步骤</strong>：</p>
<p>1）选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；</p>
<p>2）按增量序列个数k，对序列进行k 趟排序；</p>
<p>3）每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<p> <strong>代码实现：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include<stdio.h></span><br><span class="line">#include<math.h></span><br><span class="line"> </span><br><span class="line">#define MAXNUM 10</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> n,<span class="keyword">int</span> t)</span></span>;<span class="comment">//t为排序趟数</span></span><br><span class="line">    <span class="keyword">int</span> array[MAXNUM],i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i < MAXNUM;i++)</span><br><span class="line">        scanf(<span class="string">"%d"</span>,&array[i]);</span><br><span class="line">    shellSort(array,MAXNUM,<span class="keyword">int</span>(log(MAXNUM + <span class="number">1</span>) / log(<span class="number">2</span>)));<span class="comment">//排序趟数应为log2(n+1)的整数部分</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i < MAXNUM;i++)</span><br><span class="line">        printf(<span class="string">"%d "</span>,array[i]);</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//根据当前增量进行插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellInsert</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> n,<span class="keyword">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i = dk;i < n;i++)<span class="comment">//分别向每组的有序区域插入</span></span><br><span class="line">    {</span><br><span class="line">        temp = array[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i-dk;(j >= i % dk) && array[j] > temp;j -= dk)<span class="comment">//比较与记录后移同时进行</span></span><br><span class="line">            array[j + dk] = array[j];</span><br><span class="line">        <span class="keyword">if</span>(j != i - dk)</span><br><span class="line">            array[j + dk] = temp;<span class="comment">//插入</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//计算Hibbard增量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dkHibbard</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(pow(<span class="number">2</span>,t - k + <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> n,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shellInsert</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> n,<span class="keyword">int</span> dk)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i <= t;i++)</span><br><span class="line">        shellInsert(array,n,dkHibbard(t,i));</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此写法便于理解，实际应用时应将上述三个函数写成一个函数。</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="算法三：选择排序"><a href="#算法三：选择排序" class="headerlink" title="算法三：选择排序"></a>算法三：选择排序</h2><p><img alt="img" data-src="https://img2018.cnblogs.com/blog/897388/201910/897388-20191011100728171-167260035.gif" class="lozad"></p>
<p>选择排序示意图</p>
<p><strong>选择排序</strong>(Selection sort)也是一种简单直观的排序算法。</p>
<p><strong>算法步骤</strong>：</p>
<p>1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p>
<p>2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
<p>3）重复第二步，直到所有元素均排序完毕。</p>
<p> <strong>代码实现：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    register <span class="keyword">int</span> i,j,min,t;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i < n-<span class="number">1</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        min = i;<span class="comment">//查找最小值</span></span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>;j < n;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[min] > a[j])</span><br><span class="line">                min = j;<span class="comment">//交换</span></span><br><span class="line">        <span class="keyword">if</span>(min != i)</span><br><span class="line">        {</span><br><span class="line">            t = a[min];</span><br><span class="line">            a[min] = a[i];</span><br><span class="line">            a[i] = t;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="算法四：冒泡排序"><a href="#算法四：冒泡排序" class="headerlink" title="算法四：冒泡排序"></a>算法四：冒泡排序</h2><p><img alt="img" data-src="https://img2018.cnblogs.com/blog/897388/201910/897388-20191011100741370-1329207030.gif" class="lozad"></p>
<p>冒泡排序示意图</p>
<p> <strong>冒泡排序</strong>（<strong>Bubble Sort</strong>）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p><strong>算法步骤</strong>：</p>
<p>1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<p>2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
<p>3）针对所有的元素重复以上的步骤，除了最后一个。</p>
<p>4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p> <strong>代码实现：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include <stdio.h></span><br><span class="line">#define SIZE 8void bubble_sort(int a[], int n)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>;j < n - <span class="number">1</span>;j++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i < n - <span class="number">1</span> - j;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(a[i] > a[i + <span class="number">1</span>])</span><br><span class="line">            {</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> number[SIZE] = {<span class="number">95</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">78</span>, <span class="number">84</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">12</span>};</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    bubble_sort(number, SIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i < SIZE; i++)</span><br><span class="line">    {</span><br><span class="line">        printf(<span class="string">"%d"</span>, number[i]);</span><br><span class="line">    }</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="算法五：归并排序"><a href="#算法五：归并排序" class="headerlink" title="算法五：归并排序"></a>算法五：归并排序</h2><p><img alt="img" data-src="https://img2018.cnblogs.com/blog/897388/201910/897388-20191011100753556-1176644302.gif" class="lozad"></p>
<p>归并排序示意图</p>
<p><strong>归并排序（Merge sort）</strong>是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p><strong>算法步骤：</strong></p>
<p>\1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p>
<p>\2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置</p>
<p>\3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p>
<p>\4. 重复步骤3直到某一指针达到序列尾</p>
<p>\5. 将另一序列剩下的所有元素直接复制到合并序列尾</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include <stdlib.h></span><br><span class="line">#include <stdio.h></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> sourceArr[],<span class="keyword">int</span> tempArr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> midIndex, <span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = startIndex, j=midIndex+<span class="number">1</span>, k = startIndex;</span><br><span class="line">    <span class="keyword">while</span>(i != midIndex + <span class="number">1</span> && j != endIndex + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(sourceArr[i] >= sourceArr[j])</span><br><span class="line">            tempArr[k++] = sourceArr[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempArr[k++] = sourceArr[i++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(i != midIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j != endIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[j++];</span><br><span class="line">    <span class="keyword">for</span>(i = startIndex; i <= endIndex; i++)</span><br><span class="line">        sourceArr[i] = tempArr[i];</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//内部使用递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> sourceArr[], <span class="keyword">int</span> tempArr[], <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> midIndex;</span><br><span class="line">    <span class="keyword">if</span>(startIndex < endIndex)</span><br><span class="line">    {</span><br><span class="line">        midIndex = (startIndex + endIndex) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(sourceArr, tempArr, startIndex, midIndex);</span><br><span class="line">        MergeSort(sourceArr, tempArr, midIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = {<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>};</span><br><span class="line">    <span class="keyword">int</span> i, b[<span class="number">8</span>];</span><br><span class="line">    MergeSort(a, b, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i<<span class="number">8</span>; i++)</span><br><span class="line">        printf(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="算法六：快速排序"><a href="#算法六：快速排序" class="headerlink" title="算法六：快速排序"></a>算法六：快速排序</h2><p><img alt="img" data-src="https://img2018.cnblogs.com/blog/897388/201910/897388-20191011100804992-95203856.gif" class="lozad"></p>
<p>快速排序示意图</p>
<p><strong>快速排序</strong>是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 <em>n</em> 个项目要<strong>Ο</strong>(<em>n</em> log <em>n</em>)次比较。在最坏状况下则需要<strong>Ο</strong>(<em>n</em>2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他<strong>Ο</strong>(<em>n</em> log <em>n</em>) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p><strong>算法步骤：</strong></p>
<p>1 从数列中挑出一个元素，称为 “基准”（pivot），</p>
<p>2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为<strong>分区（partition）</strong>操作。</p>
<p>3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(low >= high)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> first = low;</span><br><span class="line">    <span class="keyword">int</span> last = high;</span><br><span class="line">    <span class="keyword">int</span> key = a[first];<span class="comment">/*用字表的第一个记录作为枢轴*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(first < last)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(first < last && a[last] >= key)</span><br><span class="line">        {</span><br><span class="line">            --last;</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        a[first] = a[last];<span class="comment">/*将比第一个小的移到低端*/</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(first < last && a[first] <= key)</span><br><span class="line">        {</span><br><span class="line">            ++first;</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        a[last] = a[first];    </span><br><span class="line"><span class="comment">/*将比第一个大的移到高端*/</span></span><br><span class="line">    }</span><br><span class="line">    a[first] = key;<span class="comment">/*枢轴记录到位*/</span></span><br><span class="line">    Qsort(a, low, first-<span class="number">1</span>);</span><br><span class="line">    Qsort(a, first+<span class="number">1</span>, high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="算法七：堆排序"><a href="#算法七：堆排序" class="headerlink" title="算法七：堆排序"></a>算法七：堆排序</h2><p><img alt="img" data-src="https://img2018.cnblogs.com/blog/897388/201910/897388-20191011100818541-855104008.gif" class="lozad"></p>
<p>堆排序示意图</p>
<p><strong>堆排序</strong>（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足<em>堆积的性质</em>：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序的平均时间复杂度为<strong>Ο</strong>(<em>n</em>log<em>n</em>) 。</p>
<p><strong>算法步骤：</strong></p>
<p>1）创建一个堆H[0..n-1]</p>
<p>2）把堆首（最大值）和堆尾互换</p>
<p>3）把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置</p>
<p>4） 重复步骤2，直到堆的尺寸为1</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//array是待调整的堆数组，i是待调整的数组元素的位置，nlength是数组的长度</span></span><br><span class="line"><span class="comment">//本函数功能是：根据数组array构建大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> i,<span class="keyword">int</span> nLength)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> nChild;</span><br><span class="line">    <span class="keyword">int</span> nTemp;</span><br><span class="line">    <span class="keyword">for</span>(; <span class="number">2</span> * i + <span class="number">1</span> < nLength;i = nChild)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//子结点的位置=2*（父结点位置）+1</span></span><br><span class="line">        nChild = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//得到子结点中较大的结点</span></span><br><span class="line">        <span class="keyword">if</span>(nChild < nLength - <span class="number">1</span> && array[nChild + <span class="number">1</span>] > array[nChild]) ++nChild;</span><br><span class="line">        <span class="comment">//如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点</span></span><br><span class="line">        <span class="keyword">if</span>(array[i] < array[nChild])</span><br><span class="line">        {</span><br><span class="line">            nTemp = array[i];</span><br><span class="line">            array[i] = array[nChild];</span><br><span class="line">            array[nChild] = nTemp; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">//否则退出循环</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//堆排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素</span></span><br><span class="line">    <span class="comment">//length/2-1是最后一个非叶节点，此处"/"为整除</span></span><br><span class="line">    <span class="keyword">for</span>(i = length / <span class="number">2</span> - <span class="number">1</span>;i >= <span class="number">0</span>;--i)</span><br><span class="line">    HeapAdjust(array,i,length);</span><br><span class="line">    <span class="comment">//从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = length - <span class="number">1</span>;i > <span class="number">0</span>;--i)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//把第一个元素和当前的最后一个元素交换，</span></span><br><span class="line">        <span class="comment">//保证当前的最后一个位置的元素都是在现在的这个序列之中最大的</span></span><br><span class="line">        array[i] = array[<span class="number">0</span>] ^ array[i];</span><br><span class="line">        array[<span class="number">0</span>] = array[<span class="number">0</span>] ^ array[i];</span><br><span class="line">        array[i] = array[<span class="number">0</span>] ^ array[i];</span><br><span class="line">        <span class="comment">//不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值</span></span><br><span class="line">        HeapAdjust(array,<span class="number">0</span>,i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> num[]={<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>};</span><br><span class="line">    HeapSort(num,sizeof(num)/sizeof(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i < sizeof(num) / sizeof(<span class="keyword">int</span>);i++)</span><br><span class="line">    {</span><br><span class="line">        printf(<span class="string">"%d "</span>,num[i]);</span><br><span class="line">    }</span><br><span class="line">    printf(<span class="string">"\nok\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="算法八：基数排序"><a href="#算法八：基数排序" class="headerlink" title="算法八：基数排序"></a>算法八：基数排序</h2><p><strong>基数排序</strong>是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>说基数排序之前，我们简单介绍桶排序：</p>
<p><strong>算法思想：</strong>是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。<br>简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。</p>
<p>例如要对大小为[1..1000]范围内的n个整数A[1..n]排序</p>
<p>首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储   (10..20]的整数，……集合B[i]存储(   (i-1)<em>10,   i</em>10]的整数，i   =   1,2,..100。总共有  100个桶。</p>
<p>然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。  再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任  何排序法都可以。</p>
<p>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这  样就得到所有数字排好序的一个序列了。</p>
<p>假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果</p>
<p>对每个桶中的数字采用快速排序，那么整个算法的复杂度是</p>
<p>O(n   +   m   *   n/m*log(n/m))   =   O(n   +   nlogn   –   nlogm)</p>
<p>从上式看出，当m接近n的时候，桶排序复杂度接近O(n)</p>
<p>当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的  ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。</p>
<p>前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是：</p>
<p>1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</p>
<p>2）其次待排序的元素都要在一定的范围内等等。</p>
<p> <strong>代码实现：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> <span class="comment">//辅助函数，求数据的最大位数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span>; <span class="comment">//保存最大的位数</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < n; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(data[i] >= p)</span><br><span class="line">        {</span><br><span class="line">            p *= <span class="number">10</span>;</span><br><span class="line">            ++d;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> d = maxbit(data, n);</span><br><span class="line">    <span class="keyword">int</span> *tmp = newint[n];</span><br><span class="line">    <span class="keyword">int</span> *count = newint[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i <= d; i++) <span class="comment">//进行d次排序</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j < <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j < n; j++)</span><br><span class="line">        {</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">            count[k]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j < <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j >= <span class="number">0</span>; j--) <span class="comment">//将所有桶中记录依次收集到tmp中</span></span><br><span class="line">        {</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j < n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    delete[]tmp;</span><br><span class="line">    delete[]count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各种排序的稳定性，时间复杂度、空间复杂度、稳定性总结如下图：</p>
<p><img alt="img" data-src="https://img2018.cnblogs.com/blog/897388/201910/897388-20191011100851243-1800119116.jpg" class="lozad"></p>
<p><strong>目前最受推崇的排序算法是快速排序！！！</strong></p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Huang Qingshan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://alifebug.github.io/2020/12/11/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">http://alifebug.github.io/2020/12/11/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ALifeBug.github.io">ALifeBug</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法    </a><a class="post-meta__tags" href="/tags/%E6%8E%92%E5%BA%8F/">排序    </a></div><div class="post_share"><div class="social-share" data-image="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.png"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/11/kafka%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B6%88%E8%B4%B9%E4%BF%9D%E8%AF%81%E8%B7%A8%E5%8C%BA%E6%B6%88%E8%B4%B9%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E7%A0%94%E7%A9%B6/"><img class="prev_cover lozad" data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>kafka多线程消费保证跨区消费顺序一致性的研究</span></div></a></div><div class="next-post pull-right"><a href="/2020/12/11/Java%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/"><img class="next_cover lozad" data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Java内部类详解</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/12/11/堆排序/" title="堆排序"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">堆排序</div></a></div><div class="relatedPosts_item"><a href="/2020/12/11/归并排序/" title="归并排序"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">归并排序</div></a></div><div class="relatedPosts_item"><a href="/2020/11/25/算法刷题/" title="算法刷题"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">算法刷题</div></a></div><div class="relatedPosts_item"><a href="/2020/12/11/图的遍历/" title="图的遍历"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">图的遍历</div></a></div><div class="relatedPosts_item"><a href="/2020/12/11/汉诺塔递归问题/" title="汉诺塔递归问题"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">汉诺塔递归问题</div></a></div><div class="relatedPosts_item"><a href="/2020/12/11/全排列/" title="全排列"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">全排列</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2020 By Huang Qingshan</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">简</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>