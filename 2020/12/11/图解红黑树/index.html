<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>图解红黑树 | ALifeBug</title><meta name="description" content="图解红黑树"><meta name="keywords" content="树,数据结构"><meta name="author" content="Huang Qingshan"><meta name="copyright" content="Huang Qingshan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://alifebug.github.io/2020/12/11/%E5%9B%BE%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="图解红黑树"><meta name="twitter:description" content="图解红黑树"><meta name="twitter:image" content="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><meta property="og:type" content="article"><meta property="og:title" content="图解红黑树"><meta property="og:url" content="http://alifebug.github.io/2020/12/11/%E5%9B%BE%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/"><meta property="og:site_name" content="ALifeBug"><meta property="og:description" content="图解红黑树"><meta property="og:image" content="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="数据结构中的树" href="http://alifebug.github.io/2020/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%91/"><link rel="next" title="各种编码的区别" href="http://alifebug.github.io/2020/12/11/%E5%90%84%E7%A7%8D%E7%BC%96%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">ALifeBug</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">61</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">44</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">24</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#图解红黑树"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">图解红黑树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#BST"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">BST</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#RBTree"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">RBTree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#RBTree的旋转操作"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">RBTree的旋转操作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#RBTree的插入操作"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">RBTree的插入操作</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#情况1-：当前节点的父节点是红色，且祖父节点的另一个子节点（叔叔节点）也是红色"><span class="toc_mobile_items-number">1.4.0.1.</span> <span class="toc_mobile_items-text">情况1 ：当前节点的父节点是红色，且祖父节点的另一个子节点（叔叔节点）也是红色</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#情况2：-当前节点的父节点是红的，叔叔节点是黑的，当前节点是父节点的右子树。"><span class="toc_mobile_items-number">1.4.0.2.</span> <span class="toc_mobile_items-text">情况2： 当前节点的父节点是红的，叔叔节点是黑的，当前节点是父节点的右子树。</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#情况3：当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左儿子"><span class="toc_mobile_items-number">1.4.0.3.</span> <span class="toc_mobile_items-text">情况3：当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左儿子</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#RBTree的删除操作"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">RBTree的删除操作</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#情况1：x节点时黑-黑，且x的兄弟节点是红色（x的父节点和兄弟节点的子节点都是黑色）"><span class="toc_mobile_items-number">1.5.0.1.</span> <span class="toc_mobile_items-text">情况1：x节点时黑+黑，且x的兄弟节点是红色（x的父节点和兄弟节点的子节点都是黑色）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#情况2：x节点时黑-黑，x的兄弟节点时黑色（x的兄弟节点的两个孩子都是黑色）"><span class="toc_mobile_items-number">1.5.0.2.</span> <span class="toc_mobile_items-text">情况2：x节点时黑+黑，x的兄弟节点时黑色（x的兄弟节点的两个孩子都是黑色）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#情况3：x节点是黑-黑节点，x的兄弟节点时黑色（x的兄弟节点的左儿子是红，右儿子是黑）"><span class="toc_mobile_items-number">1.5.0.3.</span> <span class="toc_mobile_items-text">情况3：x节点是黑+黑节点，x的兄弟节点时黑色（x的兄弟节点的左儿子是红，右儿子是黑）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#情况4：x节点是黑-黑节点，x的兄弟节点时黑色（x的兄弟节点的右儿子是红，左儿子随意）"><span class="toc_mobile_items-number">1.5.0.4.</span> <span class="toc_mobile_items-text">情况4：x节点是黑+黑节点，x的兄弟节点时黑色（x的兄弟节点的右儿子是红，左儿子随意）</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#图解红黑树"><span class="toc-number">1.</span> <span class="toc-text">图解红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BST"><span class="toc-number">1.1.</span> <span class="toc-text">BST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RBTree"><span class="toc-number">1.2.</span> <span class="toc-text">RBTree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RBTree的旋转操作"><span class="toc-number">1.3.</span> <span class="toc-text">RBTree的旋转操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RBTree的插入操作"><span class="toc-number">1.4.</span> <span class="toc-text">RBTree的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#情况1-：当前节点的父节点是红色，且祖父节点的另一个子节点（叔叔节点）也是红色"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">情况1 ：当前节点的父节点是红色，且祖父节点的另一个子节点（叔叔节点）也是红色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情况2：-当前节点的父节点是红的，叔叔节点是黑的，当前节点是父节点的右子树。"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">情况2： 当前节点的父节点是红的，叔叔节点是黑的，当前节点是父节点的右子树。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情况3：当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左儿子"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">情况3：当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左儿子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RBTree的删除操作"><span class="toc-number">1.5.</span> <span class="toc-text">RBTree的删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#情况1：x节点时黑-黑，且x的兄弟节点是红色（x的父节点和兄弟节点的子节点都是黑色）"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">情况1：x节点时黑+黑，且x的兄弟节点是红色（x的父节点和兄弟节点的子节点都是黑色）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情况2：x节点时黑-黑，x的兄弟节点时黑色（x的兄弟节点的两个孩子都是黑色）"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">情况2：x节点时黑+黑，x的兄弟节点时黑色（x的兄弟节点的两个孩子都是黑色）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情况3：x节点是黑-黑节点，x的兄弟节点时黑色（x的兄弟节点的左儿子是红，右儿子是黑）"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">情况3：x节点是黑+黑节点，x的兄弟节点时黑色（x的兄弟节点的左儿子是红，右儿子是黑）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情况4：x节点是黑-黑节点，x的兄弟节点时黑色（x的兄弟节点的右儿子是红，左儿子随意）"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">情况4：x节点是黑+黑节点，x的兄弟节点时黑色（x的兄弟节点的右儿子是红，左儿子随意）</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">图解红黑树</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-12-11<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-12-11</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><div class="post-meta-wordcount"><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="图解红黑树"><a href="#图解红黑树" class="headerlink" title="图解红黑树"></a>图解红黑树</h1><p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。在了解红黑树之前我们需要简述一下二叉查找树。</p>
<h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><p>二叉查找树，也称有序二叉树，是指一棵空树或者具有以下性质的二叉树：</p>
<ul>
<li>左子节点的值比父节点小</li>
<li>右子节点的值比父节点大</li>
<li>任意节点的左右字树也分别为二叉查找树</li>
<li>没有键值相等的点</li>
</ul>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-82fae99fb268f1fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300/format/webp" class="lozad"></p>
<p>BST</p>
<p>在理想情况下，二叉查找树增删改查的时间复杂度为O(logN)，但是若是二叉树极度不平衡，比如下图这样形成了一个线性链后，就会产生最坏运行情况O(N).</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-0c66413e4f5b1897.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/337/format/webp" class="lozad"></p>
<p>最坏运行复杂度</p>
<p>基于BST存在的问题，平衡二叉树产生了，典型的有AVL树和红黑树，因为AVL是严格的平衡二叉树，但是插入和删除的性能较差，所以在实际生产环境中不如红黑树应用广泛。</p>
<h2 id="RBTree"><a href="#RBTree" class="headerlink" title="RBTree"></a>RBTree</h2><p>红黑树的应用非常广泛，常见的函数库，如C++中的map，multimap,以及Java中的TreeMap，TreeSet， Java8中的HashMap的实现也采用了红黑树。</p>
<p>红黑树从本质上来说就是一颗二叉查找树，但是在二叉树的基础上增加了着色相关的性质，使得红黑树可以保证相对平衡，从而保证红黑树的增删改查的时间复杂度最坏也能达到O(log N)。</p>
<p>下面是红黑树最重要的5条性质，后面需要正常回来查看：</p>
<blockquote>
<ol>
<li>每个节点要么是黑的，要么是红的</li>
<li>根节点是黑的</li>
<li>叶节点是黑的</li>
<li>如果一个节点是红的，他的两个儿子节点都是黑的</li>
<li>对于任一节点而言，其到叶节点树尾端NIL指针的每一条路径都包含相同数目的黑节点</li>
</ol>
</blockquote>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-b99ccebc59967187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450/format/webp" class="lozad"></p>
<p>红黑树（图片引自维基百科）</p>
<p>上图是一棵典型的红黑树，红黑树的5条特性确保了从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，使得整棵树大致上是平衡的。树上的增删改查操作的最坏情况时间都与树的高度成正比，所以红黑树在最坏情况下也是高效的。</p>
<p>在红黑树中一般用黑的NIL节点表示叶节点，不包含值，只是标志该分支结束，有时候绘图中会直接省略。</p>
<p>在正式介绍红黑树插入和删除操作前，需要先了解红黑树的旋转操作。</p>
<h2 id="RBTree的旋转操作"><a href="#RBTree的旋转操作" class="headerlink" title="RBTree的旋转操作"></a>RBTree的旋转操作</h2><p>当在含n个关键字的红黑树上进行insert和delete操作时，修改后的树可能不满足上面给出的5个红黑树的基本特性，所以需要改变树中的某些节点的颜色以及指针结构。<br> 这些指针结构的修改是通过旋转完成的，旋转分为左旋和右旋:</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-1b01b878953c967f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/735/format/webp" class="lozad"></p>
<p>旋转操作</p>
<p>当在某个节点x上做左旋时，我们假设它的右孩子是y节点并且不为NIL。左旋以x到y之间的轴为支撑，左旋后，y成为该局部新的根，x成为y的做孩子，而y的左孩子成为x的右孩子，即图中的β。我们以一段伪代码说明左旋的过程:</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">y<-<span class="keyword">right</span>[x]   <span class="comment">//把x的右儿子保存为y</span></span><br><span class="line"><span class="keyword">right</span>[x]<-<span class="keyword">left</span>[y]   <span class="comment">//把y的左儿子给x作为右儿子</span></span><br><span class="line">p[<span class="keyword">left</span>[y]]<-x   <span class="comment">//把x设为y的左儿子的爸爸，这一步与上一步对应，因为指针都是双向的</span></span><br><span class="line">p[y]<-p[x]      <span class="comment">//把x的爸爸设定为y的爸爸</span></span><br><span class="line"><span class="keyword">if</span> p[x]=<span class="literal">nil</span>[<span class="type">T</span>]    <span class="comment">//如果x的爸爸本来就是空的</span></span><br><span class="line">  then root[<span class="type">T</span>]<-y  <span class="comment">//那么y就变成了根节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> x=<span class="keyword">left</span>[p[x]]   <span class="comment">//否则，如果原来x是它爸爸的左儿子</span></span><br><span class="line">    then <span class="keyword">left</span>[p[x]]<-y   <span class="comment">//就把y设为原来x爸爸的左儿子</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">right</span>[p[x]]<-y   <span class="comment">//不然就把y设为原来x爸爸的右儿子</span></span><br><span class="line"><span class="keyword">left</span>[y]<-x     <span class="comment">//x这时候转下来成为y的左儿子</span></span><br><span class="line">p[x]<-y    <span class="comment">//y 也就成了x的爸爸了</span></span><br></pre></td></tr></tbody></table></figure>

<p>在实际的树中，旋转如下所示：</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-8f928a11ac35dffd.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/986/format/webp" class="lozad"></p>
<p>旋转前</p>
<p>旋转后，18代替了11成为了7的右儿子，11，成了18的左儿子，18原先的儿子，即以14为根节点的左子树成了11的右儿子，如下所示：</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-b13fb4998b19d82c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/900/format/webp" class="lozad"></p>
<p>旋转后</p>
<p>右旋操作与左旋类似，读者们可以自行试着写出伪代码。</p>
<h2 id="RBTree的插入操作"><a href="#RBTree的插入操作" class="headerlink" title="RBTree的插入操作"></a>RBTree的插入操作</h2><p>红黑树的插入与BST的插入方式是一样的，也是通过不断比较大小，插入到合适位置，只不过插入后需要做调整，以满足红黑树的5条特性。</p>
<p>先看一下BST的插入代码：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BinaryNode<T> <span class="title">insert</span>(<span class="params">T t,BinaryNode<T> node</span>)</span></span><br><span class="line"><span class="function"></span>  {</span><br><span class="line">      <span class="keyword">if</span>(node==<span class="literal">null</span>)</span><br><span class="line">      {</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> BinaryNode<T>(t, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">int</span> result = t.compareTo(node.data);</span><br><span class="line">      <span class="keyword">if</span>(result<<span class="number">0</span>)</span><br><span class="line">         node.left= insert(t,node.left);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(result><span class="number">0</span>)</span><br><span class="line">         node.right= insert(t,node.right);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          ;<span class="comment">//doNothing</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>新插入的节点总是设为红色的，所以如果父节点为黑色，就不需要修复，因为没有任何性质被改变，所以只有在父节点为红色节点时需要做修复操作。</p>
<p>修复操作一共分为3种情况：</p>
<h4 id="情况1-：当前节点的父节点是红色，且祖父节点的另一个子节点（叔叔节点）也是红色"><a href="#情况1-：当前节点的父节点是红色，且祖父节点的另一个子节点（叔叔节点）也是红色" class="headerlink" title="情况1 ：当前节点的父节点是红色，且祖父节点的另一个子节点（叔叔节点）也是红色"></a>情况1 ：当前节点的父节点是红色，且祖父节点的另一个子节点（叔叔节点）也是红色</h4><p>此时，我们只考虑当前节点是父节点的左儿子，因为当前节点和父节点都是红色，不满足红黑树的特性4 （如果一个节点是红的，他的两个儿子节点都是黑的）。</p>
<blockquote>
<p>对策 :把父节点和叔叔节点变黑，爷爷节点涂红，然后把当前节点指针给到爷爷，让爷爷节点那层继续循环，接受红黑树特性检测。</p>
</blockquote>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-0dfea938f1dda8c8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/979/format/webp" class="lozad"></p>
<p>1.PNG</p>
<p>新插入节点1，父亲2和叔叔6都是红的，所以把2和6都变成黑的， 爷爷变成红的。</p>
<h4 id="情况2：-当前节点的父节点是红的，叔叔节点是黑的，当前节点是父节点的右子树。"><a href="#情况2：-当前节点的父节点是红的，叔叔节点是黑的，当前节点是父节点的右子树。" class="headerlink" title="情况2： 当前节点的父节点是红的，叔叔节点是黑的，当前节点是父节点的右子树。"></a>情况2： 当前节点的父节点是红的，叔叔节点是黑的，当前节点是父节点的右子树。</h4><blockquote>
<p>对策：当前节点的父节点作为新的当前节点，以新当前指点为支点左旋</p>
</blockquote>
<p>接着上面的情况1， 在情况1的操作之后，当前节点为4， 但是4的父节点3还是红的，仍然不满足红黑树的特性4， 由于叔叔节点7是黑的，且4为3的右儿子，所以满足情况2，这时候把当前节点转移到3，以3为支点左旋。4变为爷爷5的新左儿子，而原来的3下去了，成为4的左儿子。4原有的左儿子（2-1分支）给3做了右儿子。</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-aa26a912e75ad3de.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/978/format/webp" class="lozad"></p>
<p>2.PNG</p>
<h4 id="情况3：当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左儿子"><a href="#情况3：当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左儿子" class="headerlink" title="情况3：当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左儿子"></a>情况3：当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左儿子</h4><blockquote>
<p>对策： 父节点变黑，祖父变红，以祖父节点为支点右旋</p>
</blockquote>
<p>接着上面的情况2， 当前节点变成了3，由于父节点4为红，叔叔节点7 为黑，且4为5的左儿子，所以满足情况3，所以需要将父节点4变黑，祖父5变红，并且右旋，右旋后，4 的右儿子6跟了5做了左儿子，5成了4的右儿子。如图所示：</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-e0b15a51609ac829.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1034/format/webp" class="lozad"></p>
<p>3.PNG</p>
<p>这样红黑树重新恢复了平衡。上面的例子里正好遇到了三种基本情况，实际操作中也许一步就成功了，简化的来看，也就是下面三种基本情况：<br> <strong>case1 :</strong></p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-6f8c07b449b15cf8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/934/format/webp" class="lozad"></p>
<p>父红叔红</p>
<p>case2 :</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-c6c969db602e7e70.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/880/format/webp" class="lozad"></p>
<p>父红， 左子</p>
<p>case3 :</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-fa1c424467be1fb1.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1037/format/webp" class="lozad"></p>
<p>父红， 右子</p>
<p>当前节点为父节点的右节点的时候，先旋转成为左子，即case2的样子，再右旋。</p>
<p>修复操作整体来说是一个向上回溯的过程，就拿我们举得例子来说，情况1操作后，当前节点向上移到了4， 此时又会检测4 和它的父节点之间性质是否符合红黑树的5条特性，不对的话继续修复红黑树，直到当前节点转移到root节点，且root节点为黑色，修复操作结束。</p>
<h2 id="RBTree的删除操作"><a href="#RBTree的删除操作" class="headerlink" title="RBTree的删除操作"></a>RBTree的删除操作</h2><p>删除操作首先也需要做普通BST的删除操作，删除操作会删除对应的节点，叶子节点就会直接删除，如果是非叶子节点，就会用中序遍历的后继节点来顶替要删除的节点，有的书上也会用前驱节点来顶替。删除后也需要做修复操作，来满足红黑树的特性。</p>
<p>首先也是看一下BST删除节点的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">BinaryNode</span><<span class="type">T</span>> remove(<span class="type">T</span> t,<span class="type">BinaryNode</span><<span class="type">T</span>> node)</span><br><span class="line">{</span><br><span class="line">       <span class="keyword">if</span>(node == null)</span><br><span class="line">           <span class="keyword">return</span> node;<span class="comment">//没有找到,doNothing</span></span><br><span class="line">       int result = t.compareTo(node.data);</span><br><span class="line">       <span class="keyword">if</span>(result><span class="number">0</span>)</span><br><span class="line">           node.<span class="keyword">right</span> = remove(t,node.<span class="keyword">right</span>);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(result<<span class="number">0</span>)</span><br><span class="line">           node.<span class="keyword">left</span> = remove(t,node.<span class="keyword">left</span>);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(node.<span class="keyword">left</span>!=null&&node.<span class="keyword">right</span>!=null) </span><br><span class="line">       {   <span class="comment">//待删除节点有两个儿子节点时，用右儿子中的最小元素填充待删除节点</span></span><br><span class="line">           node.data = findMin(node.<span class="keyword">right</span>).data;</span><br><span class="line">           node.<span class="keyword">right</span> = remove(node.data,node.<span class="keyword">right</span>);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">else</span> <span class="comment">//只有一个儿子的时候，把父节点的儿子指针指向儿子的该独生子</span></span><br><span class="line">           node = (node.<span class="keyword">left</span>!=null)?node.<span class="keyword">left</span>:node.<span class="keyword">right</span>;</span><br><span class="line">       <span class="keyword">return</span> node;        </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>删除修复操作在遇到被删除的节点是红色节点或者到达root节点时，修复操作完毕。</p>
<p>在删除一个节点后，如果删除的节点时红色节点，那么红黑树的性质并不会被影响，此时不需要修正，如果删除的是黑色节点，原红黑树的性质就会被改变，此时我们需要做修正。</p>
<p>当黑色节点被删除后，假设该节点为y，会产生3个问题：</p>
<ol>
<li>如果y原来是根节点，而y的一个红色孩子成为新的根，则违反了性质2</li>
<li>如果y的子节点和y的父节点都是红色，那么y被删除后，两个连续的红色节点连接起来，违反了性质4</li>
<li>删除y将导致先前包含y的任何路径上的黑节点个数少1，性质5被破坏</li>
</ol>
<p>现在我们假设，顶替删除节点的那个后来节点，继承了被删除的黑色节点的那层黑色，也就是说顶替的节点具有双重颜色，如果原来是黑色，那么现在就是黑+黑，如果原来是红色，现在就是红+黑。因为有了这层额外的黑色，所以性质5还是能保持的，现在只需要恢复它的性质即可。</p>
<ul>
<li>如果当前节点时红+黑色<br> 直接把当前节点染成黑色，此时红黑树性质全部恢复</li>
<li>如果当前节点时黑+黑且是根节点，此时什么都不用做，直接结束</li>
<li>如果当前节点时黑+黑，但是不是根节点，那么又可以分为以下4种情况</li>
</ul>
<p><strong>设删除节点为x节点</strong></p>
<h4 id="情况1：x节点时黑-黑，且x的兄弟节点是红色（x的父节点和兄弟节点的子节点都是黑色）"><a href="#情况1：x节点时黑-黑，且x的兄弟节点是红色（x的父节点和兄弟节点的子节点都是黑色）" class="headerlink" title="情况1：x节点时黑+黑，且x的兄弟节点是红色（x的父节点和兄弟节点的子节点都是黑色）"></a>情况1：x节点时黑+黑，且x的兄弟节点是红色（x的父节点和兄弟节点的子节点都是黑色）</h4><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-9e121b70af57e3dc.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/980/format/webp" class="lozad"></p>
<p>x节点的兄弟节点为红色（x节点的父节点和兄弟节点的子节点都是黑色）</p>
<p>因为兄弟节点7必须有黑色孩子，我们可以改变4和7的颜色，再对4做一次左旋，而且红黑性质继续保存。完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在删除节点有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是原先红7的一个儿子），所以我们可以接下去按情形2、情形3或情形4来处理。</p>
<h4 id="情况2：x节点时黑-黑，x的兄弟节点时黑色（x的兄弟节点的两个孩子都是黑色）"><a href="#情况2：x节点时黑-黑，x的兄弟节点时黑色（x的兄弟节点的两个孩子都是黑色）" class="headerlink" title="情况2：x节点时黑+黑，x的兄弟节点时黑色（x的兄弟节点的两个孩子都是黑色）"></a>情况2：x节点时黑+黑，x的兄弟节点时黑色（x的兄弟节点的两个孩子都是黑色）</h4><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-872952f84fa1c188.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/973/format/webp" class="lozad"></p>
<p>x的兄弟节点时黑色（x的兄弟节点的两个孩子都是黑色）</p>
<p>此时我们把x的兄弟节点转变为红色，设置x的父节点为新的当前节点。<br> 其实这样做的思想是把原先x中的一个黑色属性上移。原先的x变成单纯的黑节点，而它的父节点4此时变成了红+黑，如果4原来就是黑，那么此时变成黑+黑。此时左边分支的黑节点数没有变化，但是右边4,7那一条分支，黑节点数增加了1，因为此时4也包含黑属性，所以需要通过减1个黑色节点，因为兄弟节点7的子节点都是黑的，所以直接把7 变成红的。<br> 经过上面的步骤，黑色属性转移到4中去了，这时候继续对4进行处理。</p>
<h4 id="情况3：x节点是黑-黑节点，x的兄弟节点时黑色（x的兄弟节点的左儿子是红，右儿子是黑）"><a href="#情况3：x节点是黑-黑节点，x的兄弟节点时黑色（x的兄弟节点的左儿子是红，右儿子是黑）" class="headerlink" title="情况3：x节点是黑+黑节点，x的兄弟节点时黑色（x的兄弟节点的左儿子是红，右儿子是黑）"></a>情况3：x节点是黑+黑节点，x的兄弟节点时黑色（x的兄弟节点的左儿子是红，右儿子是黑）</h4><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-2261fb10d5483a69.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/995/format/webp" class="lozad"></p>
<p>x的兄弟节点时黑色（x的兄弟节点的左儿子是红，右儿子是黑）</p>
<p>此时我们把x的兄弟节点的左儿子设为黑色，将兄弟节点设为红色，再对兄弟节点进行右旋。并且重新设置旋转后x的兄弟节点，此时是5.<br> 其实这一步只是一个中间状态，并且不是平衡的，目的是为了得到情况4的状态</p>
<h4 id="情况4：x节点是黑-黑节点，x的兄弟节点时黑色（x的兄弟节点的右儿子是红，左儿子随意）"><a href="#情况4：x节点是黑-黑节点，x的兄弟节点时黑色（x的兄弟节点的右儿子是红，左儿子随意）" class="headerlink" title="情况4：x节点是黑+黑节点，x的兄弟节点时黑色（x的兄弟节点的右儿子是红，左儿子随意）"></a>情况4：x节点是黑+黑节点，x的兄弟节点时黑色（x的兄弟节点的右儿子是红，左儿子随意）</h4><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/272719-342dd7a12c092476.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1051/format/webp" class="lozad"></p>
<p>x的兄弟节点时黑色（x的兄弟节点的右儿子是红，左儿子随意）</p>
<p>此时，把x的父节点的颜色赋给x的兄弟节点，把父节点设为黑色，将x的兄弟节点的右子节点设为黑色，再对x的父节点进行左旋。这一步操作的真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑节点的目的，这样的话，整棵树还是符合红黑树的定义的</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Huang Qingshan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://alifebug.github.io/2020/12/11/%E5%9B%BE%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/">http://alifebug.github.io/2020/12/11/%E5%9B%BE%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ALifeBug.github.io">ALifeBug</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A0%91/">树    </a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构    </a></div><div class="post_share"><div class="social-share" data-image="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.png"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%91/"><img class="prev_cover lozad" data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>数据结构中的树</span></div></a></div><div class="next-post pull-right"><a href="/2020/12/11/%E5%90%84%E7%A7%8D%E7%BC%96%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB/"><img class="next_cover lozad" data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>各种编码的区别</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/12/11/数据结构中的树/" title="数据结构中的树"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">数据结构中的树</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2020 By Huang Qingshan</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">简</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>