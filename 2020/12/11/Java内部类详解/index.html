<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Java内部类详解 | ALifeBug</title><meta name="description" content="Java内部类详解"><meta name="keywords" content="Java"><meta name="author" content="Huang Qingshan"><meta name="copyright" content="Huang Qingshan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://alifebug.github.io/2020/12/11/Java%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Java内部类详解"><meta name="twitter:description" content="Java内部类详解"><meta name="twitter:image" content="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Java内部类详解"><meta property="og:url" content="http://alifebug.github.io/2020/12/11/Java%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/"><meta property="og:site_name" content="ALifeBug"><meta property="og:description" content="Java内部类详解"><meta property="og:image" content="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="八大排序算法总结" href="http://alifebug.github.io/2020/12/11/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"><link rel="next" title="深入解析Java AtomicInteger 原子类型" href="http://alifebug.github.io/2020/12/11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Java%20AtomicInteger%20%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">ALifeBug</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">61</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">44</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">24</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Java内部类详解"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Java内部类详解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一-内部类基础"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">一.内部类基础</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二-深入理解内部类"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">二.深入理解内部类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三-内部类的使用场景和好处"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">三.内部类的使用场景和好处</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java内部类详解"><span class="toc-number">1.</span> <span class="toc-text">Java内部类详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-内部类基础"><span class="toc-number">1.1.</span> <span class="toc-text">一.内部类基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-深入理解内部类"><span class="toc-number">1.2.</span> <span class="toc-text">二.深入理解内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-内部类的使用场景和好处"><span class="toc-number">1.3.</span> <span class="toc-text">三.内部类的使用场景和好处</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Java内部类详解</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-12-11<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-12-11</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span><div class="post-meta-wordcount"><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="Java内部类详解"><a href="#Java内部类详解" class="headerlink" title="Java内部类详解"></a>Java内部类详解</h1><p>　　说起内部类这个词，想必很多人都不陌生，但是又会觉得不熟悉。原因是平时编写代码时可能用到的场景不多，用得最多的是在有事件监听的情况下，并且即使用到也很少去总结内部类的用法。今天我们就来一探究竟。下面是本文的目录大纲：</p>
<p>　　一.内部类基础</p>
<p>　　二.深入理解内部类</p>
<p>　　三.内部类的使用场景和好处</p>
<p>　　四.常见的与内部类相关的笔试面试题</p>
<h2 id="一-内部类基础"><a href="#一-内部类基础" class="headerlink" title="一.内部类基础"></a>一.内部类基础</h2><p>　　在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p>
<p>　　1.成员内部类</p>
<p>　　成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">Circle</span> </span>{``    ``<span class="keyword">double</span>` `radius = ``<span class="number">0</span>``;``    ` `    ``<span class="keyword">public</span>` `Circle(``<span class="keyword">double</span>` `radius) {``        ``<span class="keyword">this</span>``.radius = radius;``    ``}``    ` `    ``<span class="class"><span class="keyword">class</span>` `<span class="title">Draw</span> </span>{     ``<span class="comment">//内部类``        ``public` `void` `drawSahpe() {``            ``System.out.println(``"drawshape"``);``        ``}``    ``}``}`</span></span><br></pre></td></tr></tbody></table></figure>

<p>　　这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">Circle</span> </span>{``    ``<span class="keyword">private</span>` `<span class="keyword">double</span>` `radius = ``<span class="number">0</span>``;``    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">int</span>` `count =``<span class="number">1</span>``;``    ``<span class="keyword">public</span>` `Circle(``<span class="keyword">double</span>` `radius) {``        ``<span class="keyword">this</span>``.radius = radius;``    ``}``    ` `    ``<span class="class"><span class="keyword">class</span>` `<span class="title">Draw</span> </span>{     ``<span class="comment">//内部类``        ``public` `void` `drawSahpe() {``            ``System.out.println(radius);  ``//外部类的private成员``            ``System.out.println(count);   ``//外部类的静态成员``        ``}``    ``}``}`</span></span><br></pre></td></tr></tbody></table></figure>

<p>　　不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`外部类.``<span class="keyword">this</span>``.成员变量``外部类.``<span class="keyword">this</span>``.成员方法`</span><br></pre></td></tr></tbody></table></figure>

<p>　　虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">Circle</span> </span>{``    ``<span class="keyword">private</span>` `<span class="keyword">double</span>` `radius = ``<span class="number">0</span>``;` `    ``<span class="keyword">public</span>` `Circle(``<span class="keyword">double</span>` `radius) {``        ``<span class="keyword">this</span>``.radius = radius;``        ``getDrawInstance().drawSahpe();   ``<span class="comment">//必须先创建成员内部类的对象，再进行访问``    ``}``    ` `    ``private` `Draw getDrawInstance() {``        ``return` `new` `Draw();``    ``}``    ` `    ``class` `Draw {     ``//内部类``        ``public` `void` `drawSahpe() {``            ``System.out.println(radius);  ``//外部类的private成员``        ``}``    ``}``}`</span></span><br></pre></td></tr></tbody></table></figure>

<p>　　成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `<span class="class"><span class="keyword">class</span>` `<span class="title">Test</span> </span>{``    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args)  {``        ``<span class="comment">//第一种方式：``        ``Outter outter = ``new` `Outter();``        ``Outter.Inner inner = outter.``new` `Inner();  ``//必须通过Outter对象来创建``        ` `        ``//第二种方式：``        ``Outter.Inner inner1 = outter.getInnerInstance();``    ``}``}` `class` `Outter {``    ``private` `Inner inner = ``null``;``    ``public` `Outter() {``        ` `    ``}``    ` `    ``public` `Inner getInnerInstance() {``        ``if``(inner == ``null``)``            ``inner = ``new` `Inner();``        ``return` `inner;``    ``}``     ` `    ``class` `Inner {``        ``public` `Inner() {``            ` `        ``}``    ``}``}`</span></span><br></pre></td></tr></tbody></table></figure>

<p>　　内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p>
<p>　　2.局部内部类</p>
<p>　　局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">People</span></span>{``    ``<span class="keyword">public</span>` `People() {``        ` `    ``}``}` `<span class="class"><span class="keyword">class</span>` `<span class="title">Man</span></span>{``    ``<span class="keyword">public</span>` `Man(){``        ` `    ``}``    ` `    ``<span class="keyword">public</span>` `<span class="function">People <span class="title">getWoman</span><span class="params">()</span></span>{``        ``<span class="class"><span class="keyword">class</span>` `<span class="title">Woman</span> ``<span class="keyword">extends</span>` `<span class="title">People</span></span>{   ``<span class="comment">//局部内部类``            ``int` `age =``0``;``        ``}``        ``return` `new` `Woman();``    ``}``}`</span></span><br></pre></td></tr></tbody></table></figure>

<p>　　注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<p>　　3.匿名内部类</p>
<p>　　匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`scan_bt.setOnClickListener(``<span class="keyword">new</span>` `OnClickListener() {``            ` `            ``<span class="meta">@Override</span>``            ``<span class="keyword">public</span>` `<span class="keyword">void</span>` `onClick(View v) {``                ``<span class="comment">// TODO Auto-generated method stub``                ` `            ``}``        ``});``        ` `        ``history_bt.setOnClickListener(``new` `OnClickListener() {``            ` `            ``@Override``            ``public` `void` `onClick(View v) {``                ``// TODO Auto-generated method stub``                ` `            ``}``        ``});`</span></span><br></pre></td></tr></tbody></table></figure>

<p>　　这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">new</span>` `OnClickListener() {``            ` `            ``<span class="meta">@Override</span>``            ``<span class="keyword">public</span>` `<span class="keyword">void</span>` `onClick(View v) {``                ``<span class="comment">// TODO Auto-generated method stub``                ` `            ``}``        ``}`</span></span><br></pre></td></tr></tbody></table></figure>

<p>　　就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">private</span>` `<span class="keyword">void</span>` `setListener()``{``    ``scan_bt.setOnClickListener(``<span class="keyword">new</span>` `Listener1());       ``    ``history_bt.setOnClickListener(``<span class="keyword">new</span>` `Listener2());``}` `<span class="class"><span class="keyword">class</span>` `<span class="title">Listener1</span> ``<span class="keyword">implements</span>` `<span class="title">View</span>.<span class="title">OnClickListener</span></span>{``    ``<span class="meta">@Override</span>``    ``<span class="keyword">public</span>` `<span class="keyword">void</span>` `onClick(View v) {``    ``<span class="comment">// TODO Auto-generated method stub``            ` `    ``}``}` `class` `Listener2 ``implements` `View.OnClickListener{``    ``@Override``    ``public` `void` `onClick(View v) {``    ``// TODO Auto-generated method stub``            ` `    ``}``}`</span></span><br></pre></td></tr></tbody></table></figure>

<p>　　这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。</p>
<p>　　匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<p>　　4.静态内部类</p>
<p>　　静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `<span class="class"><span class="keyword">class</span>` `<span class="title">Test</span> </span>{``    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args)  {``        ``Outter.Inner inner = ``<span class="keyword">new</span>` `Outter.Inner();``    ``}``}` `<span class="class"><span class="keyword">class</span>` `<span class="title">Outter</span> </span>{``    ``<span class="keyword">public</span>` `Outter() {``        ` `    ``}``    ` `    ``<span class="keyword">static</span>` `<span class="class"><span class="keyword">class</span>` `<span class="title">Inner</span> </span>{``        ``<span class="keyword">public</span>` `Inner() {``            ` `        ``}``    ``}``}`</span><br></pre></td></tr></tbody></table></figure>

<p>　　<img alt="img" data-src="https://images0.cnblogs.com/i/288799/201407/021558444183591.jpg" class="lozad"></p>
<h2 id="二-深入理解内部类"><a href="#二-深入理解内部类" class="headerlink" title="二.深入理解内部类"></a>二.深入理解内部类</h2><p>　　1.为什么成员内部类可以无条件访问外部类的成员？</p>
<p>　　在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是Outter.java的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `<span class="class"><span class="keyword">class</span>` `<span class="title">Outter</span> </span>{``    ``<span class="keyword">private</span>` `Inner inner = ``<span class="keyword">null</span>``;``    ``<span class="keyword">public</span>` `Outter() {``        ` `    ``}``    ` `    ``<span class="keyword">public</span>` `<span class="function">Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>{``        ``<span class="keyword">if</span>``(inner == ``<span class="keyword">null</span>``)``            ``inner = ``<span class="keyword">new</span>` `Inner();``        ``<span class="keyword">return</span>` `inner;``    ``}``     ` `    ``<span class="keyword">protected</span>` `<span class="class"><span class="keyword">class</span>` `<span class="title">Inner</span> </span>{``        ``<span class="keyword">public</span>` `Inner() {``            ` `        ``}``    ``}``}`</span><br></pre></td></tr></tbody></table></figure>

<p>　　编译之后，出现了两个字节码文件：</p>
<p><img alt="img" data-src="https://images0.cnblogs.com/i/288799/201407/021630063402064.jpg" class="lozad"></p>
<p>　　反编译Outter$Inner.class文件得到下面信息：</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`E:\Workspace\Test\bin\com\cxh\test2>javap -v Outter$Inner``Compiled from ``"Outter.java"``public` `class` `com.cxh.test2.Outter$Inner ``extends` `java.lang.Object``  ``SourceFile: ``"Outter.java"``  ``InnerClass:``   ``#``24``= #``1` `of #``22``; ``//Inner=class com/cxh/test2/Outter$Inner of class com/cxh/tes``t2/Outter``  ``minor version: ``0``  ``major version: ``50``  ``Constant pool:``const` `#``1` `= ``class`        `#``2``;     ``//  com/cxh/test2/Outter$Inner``const` `#``2` `= Asciz        com/cxh/test2/Outter$Inner;``const` `#``3` `= ``class`        `#``4``;     ``//  java/lang/Object``const` `#``4` `= Asciz        java/lang/Object;``const` `#``5` `= Asciz        ``this``$``0``;``const` `#``6` `= Asciz        Lcom/cxh/test2/Outter;;``const` `#``7` `= Asciz        <init>;``const` `#``8` `= Asciz        (Lcom/cxh/test2/Outter;)V;``const` `#``9` `= Asciz        Code;``const` `#``10` `= Field       #``1``.#``11``; ``//  com/cxh/test2/Outter$Inner.this$0:Lcom/cxh/t``est2/Outter;``const` `#``11` `= NameAndType #``5``:#``6``;``//  this$0:Lcom/cxh/test2/Outter;``const` `#``12` `= Method      #``3``.#``13``; ``//  java/lang/Object."<init>":()V``const` `#``13` `= NameAndType #``7``:#``14``;``//  "<init>":()V``const` `#``14` `= Asciz       ()V;``const` `#``15` `= Asciz       LineNumberTable;``const` `#``16` `= Asciz       LocalVariableTable;``const` `#``17` `= Asciz       ``this``;``const` `#``18` `= Asciz       Lcom/cxh/test2/Outter$Inner;;``const` `#``19` `= Asciz       SourceFile;``const` `#``20` `= Asciz       Outter.java;``const` `#``21` `= Asciz       InnerClasses;``const` `#``22` `= ``class`       `#``23``;    ``//  com/cxh/test2/Outter``const` `#``23` `= Asciz       com/cxh/test2/Outter;``const` `#``24` `= Asciz       Inner;` `{``final` `com.cxh.test2.Outter ``this``$``0``;` `public` `com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);``  ``Code:``   ``Stack=``2``, Locals=``2``, Args_size=``2``   ``0``:   aload_0``   ``1``:   aload_1``   ``2``:   putfield        #``10``; ``//Field this$0:Lcom/cxh/test2/Outter;``   ``5``:   aload_0``   ``6``:   invokespecial   #``12``; ``//Method java/lang/Object."<init>":()V``   ``9``:   ``return``  ``LineNumberTable:``   ``line ``16``: ``0``   ``line ``18``: ``9` `  ``LocalVariableTable:``   ``Start  Length  Slot  Name   Signature``   ``0`      `10`      `0`    `this`       `Lcom/cxh/test2/Outter$Inner;`  `}`</span><br></pre></td></tr></tbody></table></figure>

<p>　　第11行到35行是常量池的内容，下面逐一第38行的内容：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> com.cxh.test2.Outter <span class="keyword">this</span>$<span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>　　这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</span><br></pre></td></tr></tbody></table></figure>

<p>　　从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&0引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>
<p>　　2.为什么局部内部类和匿名内部类只能访问局部final变量？</p>
<p>　　想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `<span class="class"><span class="keyword">class</span>` `<span class="title">Test</span> </span>{``    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args)  {``        ` `    ``}``    ` `    ``<span class="keyword">public</span>` `<span class="keyword">void</span>` `test(``<span class="keyword">final</span>` `<span class="keyword">int</span>` `b) {``        ``<span class="keyword">final</span>` `<span class="keyword">int</span>` `a = ``<span class="number">10</span>``;``        ``<span class="keyword">new</span>` `Thread(){``            ``<span class="keyword">public</span>` `<span class="keyword">void</span>` `run() {``                ``System.out.println(a);``                ``System.out.println(b);``            ``};``        ``}.start();``    ``}``}`</span><br></pre></td></tr></tbody></table></figure>

<p>　　这段代码会被编译成两个class文件：Test.class和Test1.class。默认情况下，编译器会为匿名内部类和局部内部类起名为Outter1.class。默认情况下，编译器会为匿名内部类和局部内部类起名为Outterx.class（x为正整数）。</p>
<p>　　<img alt="img" data-src="https://images0.cnblogs.com/i/288799/201407/021900556994393.jpg" class="lozad"></p>
<p>　　根据上图可知，test方法中的匿名内部类的名字被起为 Test$1。</p>
<p>　　上段代码中，如果把变量a和b前面的任一个final去掉，这段代码都编译不过。我们先考虑这样一个问题：</p>
<p>　　当test方法执行完毕之后，变量a的生命周期就结束了，而此时Thread对象的生命周期很可能还没有结束，那么在Thread的run方法中继续访问变量a就变成不可能了，但是又要实现这样的效果，怎么办呢？Java采用了 复制  的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容：</p>
<p><img alt="img" data-src="https://images0.cnblogs.com/i/288799/201407/021939271846598.jpg" class="lozad"></p>
<p>　　我们看到在run方法中有一条指令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bipush 10</span><br></pre></td></tr></tbody></table></figure>

<p>　　这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。</p>
<p>　　下面再看一个例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `<span class="class"><span class="keyword">class</span>` `<span class="title">Test</span> </span>{``    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args)  {``        ` `    ``}``    ` `    ``<span class="keyword">public</span>` `<span class="keyword">void</span>` `test(``<span class="keyword">final</span>` `<span class="keyword">int</span>` `a) {``        ``<span class="keyword">new</span>` `Thread(){``            ``<span class="keyword">public</span>` `<span class="keyword">void</span>` `run() {``                ``System.out.println(a);``            ``};``        ``}.start();``    ``}``}`</span><br></pre></td></tr></tbody></table></figure>

<p>　　反编译得到：</p>
<p><img alt="img" data-src="https://images0.cnblogs.com/i/288799/201407/021950384493440.jpg" class="lozad"></p>
<p>　　我们看到匿名内部类Test$1的构造器含有两个参数，一个是指向外部类对象的引用，一个是int型变量，很显然，这里是将变量test方法中的形参a以参数的形式传进来对匿名内部类中的拷贝（变量a的拷贝）进行赋值初始化。</p>
<p>　　也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</p>
<p>　　从上面可以看出，在run方法中访问的变量a根本就不是test方法中的局部变量a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在run方法中访问的变量a和test方法中的变量a不是同一个变量，当在run方法中改变变量a的值的话，会出现什么情况？</p>
<p>　　对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java编译器就限定必须将变量a限制为final变量，不允许对变量a进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p>
<p>　　到这里，想必大家应该清楚为何 方法中的局部变量和形参都必须用final进行限定了。</p>
<p>　　3.静态内部类有特殊的地方吗？</p>
<p>　　从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译class文件看一下就知道了，是没有Outter this&0引用的。</p>
<h2 id="三-内部类的使用场景和好处"><a href="#三-内部类的使用场景和好处" class="headerlink" title="三.内部类的使用场景和好处"></a>三.内部类的使用场景和好处</h2><p>　　为什么在Java中需要内部类？总结一下主要有以下四点：</p>
<p>　　1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，</p>
<p>　　2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</p>
<p>　　3.方便编写事件驱动程序</p>
<p>　　4.方便编写线程代码</p>
<p>　　个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。</p>
<p>四.常见的与内部类相关的笔试面试题</p>
<p> 1.根据注释填写(1)，(2)，(3)处的代码</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `<span class="class"><span class="keyword">class</span>` `<span class="title">Test</span></span>{``    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args){``           ``<span class="comment">// 初始化Bean1``           ``(``1``)``           ``bean1.I++;``           ``// 初始化Bean2``           ``(``2``)``           ``bean2.J++;``           ``//初始化Bean3``           ``(``3``)``           ``bean3.k++;``    ``}``    ``class` `Bean1{``           ``public` `int` `I = ``0``;``    ``}` `    ``static` `class` `Bean2{``           ``public` `int` `J = ``0``;``    ``}``}` `class` `Bean{``    ``class` `Bean3{``           ``public` `int` `k = ``0``;``    ``}``}`</span></span><br></pre></td></tr></tbody></table></figure>

<p>　　从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>
<p>　　创建静态内部类对象的一般形式为：  外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</p>
<p>　　创建成员内部类对象的一般形式为：  外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</p>
<p>　　因此，（1），（2），（3）处的代码分别为：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();    </span><br><span class="line">Test.Bean1 bean1 = test.<span class="keyword">new</span> Bean1();</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test.Bean2 b2 = <span class="keyword">new</span> Test.Bean2();</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bean bean = <span class="keyword">new</span> Bean();     </span><br><span class="line">Bean.Bean3 bean3 =  bean.<span class="keyword">new</span> Bean3();</span><br></pre></td></tr></tbody></table></figure>

<p>2.下面这段代码的输出结果是什么？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `<span class="class"><span class="keyword">class</span>` `<span class="title">Test</span> </span>{``    ``<span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args)  {``        ``Outter outter = ``<span class="keyword">new</span>` `Outter();``        ``outter.``<span class="keyword">new</span>` `Inner().print();``    ``}``}`  `<span class="class"><span class="keyword">class</span>` `<span class="title">Outter</span>``</span>{``    ``<span class="keyword">private</span>` `<span class="keyword">int</span>` `a = ``<span class="number">1</span>``;``    ``<span class="class"><span class="keyword">class</span>` `<span class="title">Inner</span> </span>{``        ``<span class="keyword">private</span>` `<span class="keyword">int</span>` `a = ``<span class="number">2</span>``;``        ``<span class="keyword">public</span>` `<span class="keyword">void</span>` `print() {``            ``<span class="keyword">int</span>` `a = ``<span class="number">3</span>``;``            ``System.out.println(``<span class="string">"局部变量："</span>` `+ a);``            ``System.out.println(``<span class="string">"内部类变量："</span>` `+ ``<span class="keyword">this</span>``.a);``            ``System.out.println(``<span class="string">"外部类变量："</span>` `+ Outter.``<span class="keyword">this</span>``.a);``        ``}``    ``}``}`</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>

<p>　　最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>
<p>　　1）成员内部类的引用方式必须为 Outter.Inner.</p>
<p>　　2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">WithInner</span> </span>{``    ``<span class="class"><span class="keyword">class</span>` `<span class="title">Inner</span></span>{``        ` `    ``}``}``<span class="class"><span class="keyword">class</span>` `<span class="title">InheritInner</span> ``<span class="keyword">extends</span>` `<span class="title">WithInner</span>.<span class="title">Inner</span> </span>{``     ` `    ``<span class="comment">// InheritInner() 是不能通过编译的，一定要加上形参``    ``InheritInner(WithInner wi) {``        ``wi.``super``(); ``//必须有这句调用``    ``}`` ` `    ``public` `static` `void` `main(String[] args) {``        ``WithInner wi = ``new` `WithInner();``        ``InheritInner obj = ``new` `InheritInner(wi);``    ``}``}`</span></span><br></pre></td></tr></tbody></table></figure></body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Huang Qingshan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://alifebug.github.io/2020/12/11/Java%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/">http://alifebug.github.io/2020/12/11/Java%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ALifeBug.github.io">ALifeBug</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java    </a></div><div class="post_share"><div class="social-share" data-image="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.png"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/11/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"><img class="prev_cover lozad" data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>八大排序算法总结</span></div></a></div><div class="next-post pull-right"><a href="/2020/12/11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Java%20AtomicInteger%20%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B/"><img class="next_cover lozad" data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>深入解析Java AtomicInteger 原子类型</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/12/11/HashMap多线程不安全/" title="HashMap多线程不安全"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">HashMap多线程不安全</div></a></div><div class="relatedPosts_item"><a href="/2020/12/11/Java常用工具类/" title="Java常用工具类"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">Java常用工具类</div></a></div><div class="relatedPosts_item"><a href="/2020/12/11/Java中的Copy-On-Write容器/" title="Java中的Copy-On-Write容器"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">Java中的Copy-On-Write容器</div></a></div><div class="relatedPosts_item"><a href="/2020/12/11/Java Sort排序原理/" title="Java Sort排序原理"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">Java Sort排序原理</div></a></div><div class="relatedPosts_item"><a href="/2020/12/11/java基本数据类型取值范围/" title="Java基本数据类型取值范围"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">Java基本数据类型取值范围</div></a></div><div class="relatedPosts_item"><a href="/2020/12/11/Java的多态性/" title="Java的多态性"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">Java的多态性</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2020 By Huang Qingshan</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">简</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>