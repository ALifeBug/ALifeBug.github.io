<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>MySQL技术内幕：InnoDB存储引擎 | ALifeBug</title><meta name="description" content="MySQL技术内幕：InnoDB存储引擎"><meta name="keywords" content="Mysql"><meta name="author" content="Huang Qingshan"><meta name="copyright" content="Huang Qingshan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://alifebug.github.io/2020/04/06/MySQL/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="MySQL技术内幕：InnoDB存储引擎"><meta name="twitter:description" content="MySQL技术内幕：InnoDB存储引擎"><meta name="twitter:image" content="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><meta property="og:type" content="article"><meta property="og:title" content="MySQL技术内幕：InnoDB存储引擎"><meta property="og:url" content="http://alifebug.github.io/2020/04/06/MySQL/"><meta property="og:site_name" content="ALifeBug"><meta property="og:description" content="MySQL技术内幕：InnoDB存储引擎"><meta property="og:image" content="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="RSA算法" href="http://alifebug.github.io/2020/04/07/RSA%E7%AE%97%E6%B3%95/"><link rel="next" title="看透Spring MVC: 源代码分析与实践" href="http://alifebug.github.io/2020/04/01/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">ALifeBug</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#MySQL技术内幕：InnoDB存储引擎"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">MySQL技术内幕：InnoDB存储引擎</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总体架构"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">总体架构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#文件"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">文件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#表"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#索引和算法"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">索引和算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-NaN"><a class="toc_mobile_items-link" href="#null"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#锁"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#事务"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">事务</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL技术内幕：InnoDB存储引擎"><span class="toc-number">1.</span> <span class="toc-text">MySQL技术内幕：InnoDB存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#总体架构"><span class="toc-number">1.1.</span> <span class="toc-text">总体架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件"><span class="toc-number">1.2.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表"><span class="toc-number">1.3.</span> <span class="toc-text">表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引和算法"><span class="toc-number">1.4.</span> <span class="toc-text">索引和算法</span></a></li><li class="toc-item toc-level-NaN"><a class="toc-link" href="#null"><span class="toc-number"></span> <span class="toc-text">)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁"><span class="toc-number">1.5.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务"><span class="toc-number">1.6.</span> <span class="toc-text">事务</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">MySQL技术内幕：InnoDB存储引擎</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-06<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-10</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Mysql/">Mysql</a></span><div class="post-meta-wordcount"><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="MySQL技术内幕：InnoDB存储引擎"><a href="#MySQL技术内幕：InnoDB存储引擎" class="headerlink" title="MySQL技术内幕：InnoDB存储引擎"></a>MySQL技术内幕：InnoDB存储引擎</h1><p><img alt="Gr1FOA.jpg" data-src="https://s1.ax1x.com/2020/04/05/Gr1FOA.jpg" class="lozad"></p>
<h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p>InnoDB存储引擎有多个内存块，组成一个内存池，如图。</p>
<ul>
<li><p>内存池用来维护所有进程/线程的内部数据结构，缓存磁盘数据，方便读取，并在对磁盘数据修改时缓存修改的数据，重做日志(redo log)缓冲。</p>
</li>
<li><p>后台线程就是用来负责刷新缓存，保证缓存是最新数据，并将文件修改刷新到磁盘，简而言之就是维护缓存，以及保证数据异常后恢复正常运行。InnoDB存储引擎是多线程模型，包括核心线程Master Thread(异步刷新缓冲池，脏页刷新，合并插入缓冲，刷新重做缓冲到重做文件等)、IO Thread,Purge Thread，Page Cleaner Thread。</p>
</li>
</ul>
<p>数据库页的修改，会先修改缓冲池，再刷新到磁盘，但是并不是每次修改都会刷新回去，而是通过Checkpoint机制刷新回磁盘。缓冲池的内容如下:</p>
<p><img alt="Grti6S.png" data-src="https://s1.ax1x.com/2020/04/05/Grti6S.png" class="lozad"></p>
<ul>
<li>通常数据库缓冲池是通过LRU算法管理的，即最频繁使用的页在LRU列表前端，最少使用的页在LRU列表尾端。不能存放新读取的页时，会先释放尾端的页。不过InnoDB中最新访问的页是放在midpoint位置(默认是5/8处)，即插入到LRU列表尾端的37%处，之后的列表为old列表，前面的是new列表，new列表的页都是最活跃的热点数据。这是因为在某些操作(索引或数据的扫描操作)中需要访问很多甚至全部页，但并不频繁，就可能把热点数据挤出去，下一次又要重新读回来。</li>
</ul>
<p>命令<code>SHOW VARIABLES LIKE 'innodb_buffer_pool_size'</code>查看缓冲池大小，字节单位</p>
<p>命令<code>SHOW ENGINE INNODB STATUS</code>可以用来观察缓冲池状态：</p>
<p><img alt="GrNvGt.png" data-src="https://s1.ax1x.com/2020/04/05/GrNvGt.png" class="lozad"></p>
<p>上图显示的是过去24秒的状态，不是当前状态。</p>
<p>Buffer pool size 显示有327679个页，也就是327679*16KB=5GB,1.0.X版本后支持1KB,2KB,4KB,8KB的压缩页，通过unzip_LRU列表管理</p>
<p>Free buffers表示空闲页的数量</p>
<p>Database pages表示LRU列表中页的数量，与free buffers相加小于Buffer pool size，因为还有其他页比如insert buffer不存在LRU列表中。</p>
<p>Buffer pool hit rate显示100%，表示缓冲池的命中率，不应该小于95%，否则应该考虑全表扫描造成的LRU列表被污染的问题。</p>
<ul>
<li><p>LRU列表中的页被修改后成为脏页，与磁盘数据不一致了，FLUSH列表中的页就是脏页列表，但是脏页同时存在LRU列表和FLUSH列表中，通过CHECKPOINT机制刷新回磁盘，二者互不影响。</p>
</li>
<li><p>为了避免数据丢失，当前事务数据库系统普遍采用Write Ahead Log策略，事务提交时，先写重做日志，再修改页。如果宕机，可以通过重做日志来恢复数据，这是ACID中D(持久性)的要求。重做日志缓冲存放重做日志信息，按一定频率刷新到重做日志文件，一般每隔一秒刷新一次，只要保证每秒事务量在这个缓冲大小之内即可，默认8M，足以满足绝大部分应用。</p>
</li>
<li><p>Checkpoint所做的事无外乎将缓冲池中的脏页刷回到磁盘，只不过时间、条件和脏页选择很复杂。分为Sharp Checkpoint,在数据库关闭时刷新脏页，以及Fuzzy(模糊的) Checkpoint，后者又分为Master Thread Checkpoint:Master Thread以每秒或十秒的速度异步刷新一定比例脏页回磁盘，用户查询线程不会阻塞;FLUSH_LRU_LIST checkpoint:LRU列表需要保证有一定数量的空闲页可用，所以会定期检查并将超出的尾端页移除，有脏页就刷新回磁盘。Async/Sync Flush Checkpoint:重做日志不可用，需要强制刷新一些页回去;Dirty Page too much:脏页太多，强制进行Checkpoint。</p>
</li>
<li><p>InsertBuffer对于非唯一的辅助索引（一般为非聚集索引），通过缓冲将多个插入合并到一个操作中，提高插入性能，两次写操作是说操作系统将页写入磁盘时发生崩溃，恢复过程中，可以从共享表空间的doublewrite中找到该页的一个副本复制到表空间文件中，再应用重做日志，目的是防止因为页本身的损坏造成的数据丢失。InnoDB会监控对表上各索引页的查询，如果观察到建立哈希索引会提升速度，就建立哈希索引，称为自适应哈希索引，它会自动根据访问的频率模式为某些热点页建立哈希索引，但是哈希索引只能用于搜索等值的查询，不能范围查找。</p>
</li>
<li><p>AIO对应的是Sync IO,即每进行一次IO，都要等待此次操作结束才继续下面的操作，比如一次索引扫描，每扫描一个页等待完成后再进行下一次扫描，完全没必要。AIO可以在发出一个IO请求后立刻再发出另一个IO请求，全部IO请求发送完毕后等待所有IO操作完成。read ahead，脏页刷新，磁盘写入都是由AIO完成。当刷新一个脏页时，InnoDB会检测该页所在区(extent)的所有页，如果是脏页，那么一起刷新，好处是通过AIO将多个IO操作合并为一个IO操作。</p>
</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li><p>MySQL实例启动时，会先去读一个配置参数文件，用来寻找数据库的各种文件所在位置以及某些初始化参数，这些参数定义了某种内存数据结构有多大。可以通过命令<code>mysql --help|grep my.cnf</code>来寻找。</p>
</li>
<li><p>数据库参数可以被看成是一个个键值对，如innodb_buffer_pool_size=1G,可以通过命令SHOW VARIABLES查看数据库所有参数,或通过LIKE过滤参数名。参数分为动态和静态，静态不可修改，动态参数有些只能在会话中修改如autocommit，有些修改后在实例的整个生命周期都有效，但是在下一次启动MySQL实例后还是会读取配置文件中的参数。</p>
</li>
</ul>
<p>MySQL中的日志文件有:错误日志(error log),二进制日志(binlog),慢查询日志(slow query log),查询日志(log)</p>
<ul>
<li><p>错误日志对mysql的启动运行关闭都进行了记录，所以遇到问题时比如数据库不能正常启动，先看error log，通过命令<code>SHOW VARIABLES LIKE 'log_error'</code>定位文件(一般在/var/log/mysql)。</p>
</li>
<li><p>慢查询日志可以在MYSQL启动时设一个阈值，将运行时间超过该值的SQL语句都记录到慢查询日志文件中，该阈值可以通过参数<code>long_query_time</code>设置，默认10秒。默认情况下慢查询日志是关闭的，需要手动开启。</p>
</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>; //返回开启状态，以及日志文件位置</span><br><span class="line">全局配置</span><br><span class="line">mysql> set global slow_query_log='ON'; //设置开启</span><br><span class="line">mysql> set global slow_query_log_file='/usr/local/mysql/data/slow.log'; //linux 设置文件位置</span><br><span class="line">mysql> set global slow_query_log_file='D:\\mysq\data\slow.log';         //windows</span><br><span class="line">配置文件配置(重启不影响)</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log = ON</span><br><span class="line">slow_query_log_file = /usr/local/mysql/data/slow.log     //linux</span><br><span class="line">long_query_time = 1</span><br><span class="line">service mysqld restart</span><br></pre></td></tr></tbody></table></figure>

<p>如果运行的SQL语句没有使用索引，则Mysql也会将这条sql语句记录到慢查询日志，相关参数是<code>log_queries_not_using_indexes</code>通过<code>show variables like 'log_queries_not_using_indexes'</code>查询开启状态。如果太多得到SQL查询被记录到慢查询日志文件中，可以通过<code>mysqldumpslow xxx.log</code>命令解决。比如想要得到运行时间最长的10条SQL语句，可以运行：<code>mysqldumpslow -s al -n 10 xxx.log</code>。MySQL 5.1开始将慢查询日志记录放入一张表中，名为<code>mysql.slow_log</code>。参数<code>log_output</code>指定了慢查询输出的格式，默认为<code>FILE</code>，可以指定为<code>TABLE</code>。这个参数是动态全局参数。不过slow_log表的定义是CSV引擎，大数据量下效率不高，可以通过将该表的引擎转换到MyISAM,并在start_time列上添加索引提高查询效率。</p>
<ul>
<li><p>查询日志记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确执行。默认文件名：主机名.log。</p>
</li>
<li><p>二进制日志记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作，因为这类操作对数据本身没有修改。二进制日志的作用主要有恢复某些数据，通过复制和执行二进制日志使远程数据库(Slave)与主数据库(Master)同步，审计即通过二进制日志信息判断是否有数据库注入式攻击。使用命令<code>show variables like 'datadir'</code>查看日志存放位置，默认情况下没有启动，需要手动指定参数启动。二进制文件需要用<code>mysqlbinlog</code>工具查看。如图，其中的bin_log.00001就是二进制日志文件，默认名为<code>mysql-bin.000001</code>,bin_log.index为二进制的索引文件，存储过往产生的二进制日志序号。<img alt="GyaU1I.png" data-src="https://s1.ax1x.com/2020/04/06/GyaU1I.png" class="lozad"></p>
</li>
<li><p>无论数据表采用何种存储引擎，MySQL都有一个以frm为后缀名的文件，这个文件记录了该表的表结构定义，还用来存放视图的定义。</p>
</li>
<li><p>InnoDB将存储的数据按表空间进行存放，默认会有一个初始10MB，名为ibdata1的文件。该文件就是默认的表空间文件。文件可以自动增长(autoextend)。若设置了参数<code>innodb_file_per_table</code>,则用户可以将每个基于InnoDB存储引擎的表产生一个独立表空间，该变量只能在配置文件里修改。命名为:表名.ibd。但是单独的表空间文件仅存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认表空间中，如果关闭则建表时只生成.frm文件，数据和索引都放在共享表空间ibdata1中。</p>
</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql>show variables like 'innodb_data_file_path';</span><br><span class="line">+<span class="comment">-----------------------+------------------------+</span></span><br><span class="line">| Variable_name         | Value                  |</span><br><span class="line">+<span class="comment">-----------------------+------------------------+</span></span><br><span class="line">| innodb_data_file_path | ibdata1:12M:autoextend |</span><br><span class="line">+<span class="comment">-----------------------+------------------------+</span></span><br><span class="line">mysql> show variables like 'innodb_file_per_table';</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| innodb_file_per_table | ON    |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>重做日志文件(redo log file)，在InnoDB存储引擎的数据目录(通过<code>show variables like 'datadir</code>查看，默认是/var/lib/mysql)下，会有两个名为ib_logfile0,ib_logfile1的文件，即为重做日志文件，记录了事务日志。比如数据库断电后丢失数据可以使用该文件恢复。二进制日志记录的是一个事务的具体操作内容，同时还记录其他存储引擎的和数据库有关的日志，属于逻辑日志，而重做日志记录的是每个页的更改的物理情况，并且只针对InnoDB引擎。二进制日志仅在事务提交前提交，只写磁盘一次，无论事务多大，而在事务进行过程中，不断有重做日志被写入重做日志文件中。</li>
</ul>
<p><strong>总结</strong>：与MySQL相关的文件中，错误文件和二进制文件非常重要，发生任何错误应该首先查看错误文件，错误文件还记录了一些警告信息。二进制文件可以用来point in time的恢复以及复制环境的搭建。表空间文件用来管理InnoDB存储引擎的存储，分为共享表空间和独立表空间。重做日志用来记录事务日志。</p>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>InnoDB存储引擎表中，每张表都有个主键，如果创建表时没有显式定义主键，则会按如下方式选择或创建主键：</p>
<ul>
<li><p>先判断表中是否有非空的唯一索引，如果有，则该列为主键。</p>
</li>
<li><p>如果不符合上述条件，InnoDB存储引擎会自动创建6字节大小的指针。</p>
</li>
<li><p>主键的选择是定义索引的顺序，不是建表时列的顺序。</p>
</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql> CREATE TABLE z (￼   </span><br><span class="line">    -> a INT NOT NULL,￼</span><br><span class="line">    -> b INT NULL,￼</span><br><span class="line">    -> c INT NOT NULL,</span><br><span class="line">    -> d INT NOT NULL,￼</span><br><span class="line">    -> UNIQUE KEY (b),</span><br><span class="line">    -> UNIQUE KEY (d), UNIQUE KEY (c));￼</span><br><span class="line">    Query OK, 0 rows affected (0.02 sec)￼</span><br><span class="line">    d为首个非空的唯一索引，所以d为主键.</span><br><span class="line">    <span class="keyword">select</span> a,b,c,d,_rowid <span class="keyword">from</span> z;中的_rowid可以显示表的主键。不过显示定义了PRIMARY KEY或者是联合主键的话就无法使用_rowid查看了</span><br></pre></td></tr></tbody></table></figure>



<h2 id="索引和算法"><a href="#索引和算法" class="headerlink" title="索引和算法"></a>索引和算法</h2><p>InnoDB支持B+树索引，全文索引，哈希索引。哈希索引是自适应的，不能人为生成。B+树索引是传统意义上的索引。B+树索引并不能找到一个给定键值的具体行，它能找到的只是被查找数据行所在的页，然后数据库把页读入到内存，再在内存中进行查找，最后找到要查找的数据。</p>
<ul>
<li><p>二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，所以可以通过二叉查找树来查找相应键值，比顺序查找效率更高。</p>
</li>
<li><p>但是，二叉查找树可以任意构造，也就是可以构造出高度不一的二叉查找树，若想最大性能的构造一棵二叉查找树，就需要这棵二叉查找树是平衡的，即平衡二叉树，或称AVL树。它必须满足任何节点的两个子树的高度最大差为1。</p>
</li>
<li><p>平衡二叉树的查找性能是比较高的，但不是最高的，只是接近最高性能。最好的性能需要建立一棵最优二叉树，但是最优二叉树的建立和维护需要大量操作，因此只需要建立一棵平衡二叉树即可。</p>
</li>
<li><p>平衡二叉树需要通过左旋和右旋维护结构，代价很高，多用于内存结构对象中。</p>
</li>
</ul>
<p><img alt="GWoouj.png" data-src="https://s1.ax1x.com/2020/04/08/GWoouj.png" class="lozad"></p>
<p>如图是一棵B+树，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接，高度为2，每页可存放4条记录，扇出为5。用户从最左边的叶子节点开始顺序遍历，可以得到所有键值的顺序排序。B+树相对于B树其非叶子节点仅具有索引作用，并且所有叶节点构成双向有序链表。</p>
<ul>
<li><p>B+索引一个特点就是高扇出性，因此在数据库中，B+树的高度一般都在2<del>4层，也就是说查找某一键值的行记录最多只需要2</del>4次IO。数据库的聚集索引和辅助索引都是B+树的，叶子节点存放所有数据，但是区别在于叶子节点存放的是否是一整行的信息。</p>
</li>
<li><p>聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点存放的即为整张表的行记录数据，也将聚集索引的叶子节点成为数据页。因此每张表只能拥有一个聚集索引，聚集索引能特别快的访问针对范围值的查询，比如排序查询(order by)和范围查询(<,>)</p>
</li>
<li><p>辅助索引不影响数据在聚集索引中的组织，每张表可以有多个辅助索引，通过辅助索引查找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。如果在一棵高度为3的辅助索引树中查找数据，那需要对这棵辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问以得到最终的一个数据页。</p>
</li>
<li><p>索引的创建删除：</p>
<ul>
<li><p>查看索引</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用alter table创建索引</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">index</span> 索引名(字段名);创建普通索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">unique</span> 索引名(字段名);创建唯一索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> primary <span class="keyword">key</span> (字段名);创建主键索引</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用create index增加索引</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(字段名);创建普通索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(字段名);创建唯一索引</span><br><span class="line">不能用<span class="keyword">create</span> <span class="keyword">index</span>创建primary <span class="keyword">key</span>索引，但可以在创建表的时候就指定主键索引:</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> mytable(</span><br><span class="line">	<span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">ID</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>删除索引</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">index</span> 索引名;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>组合索引</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">index</span> 索引名(字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3</span>);</span><br><span class="line">实际上建立了三组索引:1.字段1,字段2,字段3 2.字段1,字段2 3.字段1 符合最左前缀原则</span><br><span class="line">因为数据是先后按照字段1,2,3的顺序排序的，所以对于联合索引(a,b)来说，下列语句可以直接使用联合索引得到结果：<span class="keyword">select</span> ... <span class="keyword">from</span> 表名 <span class="keyword">where</span> a=xxx <span class="keyword">order</span> <span class="keyword">by</span> b</span><br><span class="line">或者对于联合索引(a,b,c)来说，下列语句也可以使用联合索引：</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> 表名 <span class="keyword">where</span> a=xxx <span class="keyword">order</span> <span class="keyword">by</span> b</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> 表名 <span class="keyword">where</span> a=xxx <span class="keyword">and</span> b=xxx <span class="keyword">order</span> <span class="keyword">by</span> c</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
</li>
</ul>
<p><img alt="Gfi9UK.png" data-src="https://s1.ax1x.com/2020/04/08/Gfi9UK.png" class="lozad"></p>
<p>Non_unique：非唯一的索引，可以看到primary key是0，因为必须是唯一的。</p>
<p>Key_name：索引的名字，用户可以通过这个名字来执行DROP INDEX。</p>
<p>Seq_in_index：索引中该列的位置，如果看联合索引就比较直观了</p>
<p>Column_name：索引列的名称。</p>
<p>Collation：列以什么方式存储在索引中。可以是A或NULL。B+树索引总是A，即排序的。如果使用了Heap存储引擎，并且建立了Hash索引，这里就会显示NULL了。因为Hash根据Hash桶存放索引数据，而不是对数据进行排序。</p>
<p>Cardinality：非常关键的值，表示索引中唯一值的数目的估计值。如果非常小，那么用户需要考虑是否可以删除此索引。但是这个值并不是实时更新的，即并非每次索引的更新都会更新该值，因为这样代价太大了。因此这个值是不太准确的，只是一个大概的值。如果需要更新索引Cardinality的信息，可以使用<code>ANALYZE TABLE</code>命令。</p>
<p>Sub_part：是否是列的部分被索引，比如对VARCHAR的前100个字符进行索引。</p>
<p>Packed：关键字如何被压缩。如果没有被压缩，则为NULL。</p>
<p>Null：是否索引的列允许含有NULL值。</p>
<p>Index_type：索引的类型。InnoDB存储引擎只支持B+树索引，所以这里显示的都是BTREE。</p>
<p>Comment：注释。</p>
<p>索引通常创建在取值范围很广，几乎没有重复，属于高选择性的字段，比如姓名字段，而不是性别字段。也就是说Cardinality/n_rows_in_table应尽可能地接近于1。</p>
<ul>
<li>覆盖索引：指从辅助索引中就可以得到查询的记录，所以不用查询聚集索引中的记录。</li>
<li>哈希索引：InnoDB采用除法散列产生哈希值，并通过链表法解决哈希冲突，不过都是数据库自身创建使用的。</li>
<li>全文检索是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术，需要在某个类型为char、varchar、text 及其系列的字段上创建全文索引，用以取代<code>like %xxx%</code>对于大数据量的模糊查询。 </li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">建表时同时创建全文索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> fulltext_test (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">content</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    tag <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    FULLTEXT <span class="keyword">KEY</span> content_tag_fulltext(<span class="keyword">content</span>,tag)  // 创建联合全文索引列</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line">在已有的表上创建全文索引</span><br><span class="line"><span class="keyword">create</span> fulltext <span class="keyword">index</span> content_tag_fulltext</span><br><span class="line">    <span class="keyword">on</span> fulltext_test(<span class="keyword">content</span>,tag);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> fulltext_test</span><br><span class="line">    <span class="keyword">add</span> fulltext <span class="keyword">index</span> content_tag_fulltext(<span class="keyword">content</span>,tag);   </span><br><span class="line">  </span><br><span class="line">删除全文索引</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> content_tag_fulltext</span><br><span class="line">    <span class="keyword">on</span> fulltext_test;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> fulltext_test</span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">index</span> content_tag_fulltext;</span><br><span class="line">    </span><br><span class="line">使用全文索引</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> fulltext_test </span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">match</span>(<span class="keyword">content</span>,tag) against(<span class="string">'xxx xxx'</span>);</span><br><span class="line">    </span><br><span class="line">使用全文索引时，有最小搜索长度和最大搜索长度的限制，即词语的长度必须在这个区间内</span><br><span class="line">mysql> show variables like '%ft%';</span><br><span class="line">+<span class="comment">---------------------------------+----------------+</span></span><br><span class="line">| Variable_name                   | Value          |</span><br><span class="line">+<span class="comment">---------------------------------+----------------+</span></span><br><span class="line">| ft_boolean_syntax               | + -><()~*:""&| |</span><br><span class="line">| ft_max_word_len                 | 84             |</span><br><span class="line">| ft_min_word_len                 | 4              |</span><br><span class="line">| ft_query_expansion_limit        | 20             |</span><br><span class="line">| ft_stopword_file                | (built-in)     |</span><br><span class="line">| innodb_ft_aux_table             |                |</span><br><span class="line">| innodb_ft_cache_size            | 8000000        |</span><br><span class="line">| innodb_ft_enable_diag_print     | OFF            |</span><br><span class="line">| innodb_ft_enable_stopword       | ON             |</span><br><span class="line">| innodb_ft_max_token_size        | 84             |</span><br><span class="line">| innodb_ft_min_token_size        | 3              |</span><br><span class="line">| innodb_ft_num_word_optimize     | 2000           |</span><br><span class="line">| innodb_ft_result_cache_limit    | 2000000000     |</span><br><span class="line">| innodb_ft_server_stopword_table |                |</span><br><span class="line">| innodb_ft_sort_pll_degree       | 2              |</span><br><span class="line">| innodb_ft_total_cache_size      | 640000000      |</span><br><span class="line">| innodb_ft_user_stopword_table   |                |</span><br><span class="line">+<span class="comment">---------------------------------+----------------+</span></span><br><span class="line">可以看到MyISAM的区间为4~84,InnoDB的区间为3~84</span><br></pre></td></tr></tbody></table></figure>

<p>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。它是默认的全文搜索引擎。<br>在布尔搜索中，我们可以在查询中自定义某个被搜索的词语的相关性，当编写一个布尔搜索查询时，可以通过一些前缀修饰符来定制搜索。比如+必须包含该词，-必须不包含该词，>提高该词的相关性，查询结果靠前，<降低该词的相关性，查询结果靠后。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">match</span>(<span class="keyword">content</span>) against(<span class="string">'a*'</span> <span class="keyword">in</span> <span class="built_in">boolean</span> <span class="keyword">mode</span>);</span><br></pre></td></tr></tbody></table></figure>



<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>InnoDB提供一致性的非锁定读、行级锁支持，行级锁没有相关额外的开销，并可以同时得到并发性和一致性。MyISAM引擎的锁是表锁设计，并发情况下的读没有问题，但是并发插入时的性能就差一些了。</p>
<p>latch指的是闩锁(轻量级锁)，因为其要求锁定的时间必须非常短。在InnoDB中又分为mutex(互斥量)和rwlock(读写锁)，其目的是保证并发线程操作临界资源的正确性，并且通常没有死锁检测机制。lock的对象是事务，锁定的是数据库中的对象，如表、页、行。并且lock的对象一般仅在事务commit或rollback后进行释放，有死锁机制。</p>
<p>InnoDB提供两种标准的行级锁：共享锁(S Lock)和排他锁(X Lock)。</p>
<p><img alt="GT9tG6.jpg" data-src="https://s1.ax1x.com/2020/04/10/GT9tG6.jpg" class="lozad"></p>
<p>这里的S和X锁都是行级锁，兼容是指对同一记录锁的兼容性情况。</p>
<p>此外，InnoDB支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了实现不同粒度上的加锁，InnoDB支持一种额外的锁方式——意向锁。将锁定的对象分为多个层次，可以看成一棵树结构，如果想对最下层的对象上锁，首先需要对粗粒度的对象上锁。</p>
<p><img alt="GTCRt1.jpg" data-src="https://s1.ax1x.com/2020/04/10/GTCRt1.jpg" class="lozad"></p>
<p>如图，如果要对页上的记录r上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一部分等待，则该操作需要等待粗粒度锁的完成，比如在对记录r上X锁之前，已经有事务对表1进行了S表锁，由于需要对表1加上IX意向锁，因为不兼容，所以需要等待表锁操作完成。InnoDB的意向锁即为表级别的锁，支持两种意向锁：1.意向共享锁，事务想要获得一张表中某几行的共享锁 2.意向排他锁，事务想要获得一张表中某几行的排他锁。</p>
<p><img alt="GTFUkd.jpg" data-src="https://s1.ax1x.com/2020/04/10/GTFUkd.jpg" class="lozad"></p>
<p>一致性非锁定读是指InnoDB通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，读取操作不会因此去等待行上锁的释放，它会去读取行的一个快照数据，快照数据是该行的之前版本的数据，该实现通过undo段完成。</p>
<p>innodb通过<strong>force log at commit</strong>机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。undo log和redo log记录物理日志不一样，它是逻辑日志。<strong>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</strong>当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚，当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p>
<p>默认配置下，非锁定读是默认的读取方式，不会占用和等待表上的锁。</p>
<p>读已提交(Read Commited)事务隔离级别下，总是读取最新一份快照数据，而可重复读(Repeatable Read)总是读取事务开始时的行数据版本，因为要保证可重复读。举例说明：</p>
<p>首先开启了一个事务A，执行语句<code>Select * from parent where id =1;</code>，读取了id为1的数据，事务还没有结束，此时开启了事务B，并且执行了语句<code>update parent set id=3 where id=1;</code>，事务同样没有提交，这样id=1的行其实加了一个X锁。此时如果事务A再次读取id为1的记录，在读已提交和可重复读两种隔离级别下读出的id都是1，但是B事务提交后，A事务再去读，由于读已提交总是读取最新版本数据，如果行被锁定了，则读取该行版本的最新快照，所以读出来的将是empty set，而可重复读总是读取事务开始时的行数据版本，所以读到的还是1。</p>
<p><img alt="GTlrPf.jpg" data-src="https://s1.ax1x.com/2020/04/10/GTlrPf.jpg" class="lozad"></p>
<p>虽然默认情况下，隔离级别为REPEATABLE READ，SELECT操作使用一致性非锁定读。但在某些情况，还是需要显式对数据库读取操作加锁以保证数据逻辑的一致性。InnoDB对SELECT操作支持两种一致性锁定读操作:</p>
<p><code>SELECT...FOR UPDATE</code>,对读取的行记录加一个X锁，其他事务不能对已锁定的行加任何锁，但是依然可以通过一致性非锁定读来读取。<code>SELECT...LOCK IN SHARE MODE</code>对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是加X锁就会被阻塞。两种语句必须在事务中执行，也就是加上BEGIN,START TRANSACTION或者SET AUTOCOMMIT=0。</p>
<p>数据库中的脏页指的是缓冲池中已经被修改的页，但还没有被刷新到磁盘中，并不影响数据一致性，并且因为脏页刷新是异步的，不影响数据库可用性，因此可以带来性能的提高。但是脏数据是指未提交的数据，脏读指的是在不同事务下，当前事务可以读到另外事务未提交的数据，也就是脏数据。</p>
<p><img alt="GTttYR.jpg" data-src="https://s1.ax1x.com/2020/04/10/GTttYR.jpg" class="lozad"></p>
<p>不可重复读，指的是一个事务还没有结束，另一个事务做了一些DML操作，第一个事务读到的两次数据不一样，相比于脏读读到的是未提交的数据，而不可重复读读到的却是已提交的数据，但是违反了数据库事务一致性的要求。</p>
<p><img alt="GTNaNj.jpg" data-src="https://s1.ax1x.com/2020/04/10/GTNaNj.jpg" class="lozad"></p>
<p>丢失更新指的是一个事务的更新操作会被另一个事务的更新操作覆盖，从而导致数据不一致。但是在当前数据库的任何隔离级别下，都不会导致理论意义上的丢失更新问题，因为即使是READ UNCOMMITTED隔离级别，也会在DML操作(增、删、改)时对行或其他粗粒度级别对象加锁。但是在生产应用中会出现逻辑意义上的丢失更新问题，而导致该问题的并不是数据库本身的问题，简单来说就是用户打开一个页面看到了数据a，然后去修改它为c，在他提交修改之前可能有人已经修改过这个数据了变成b，这样的话他所做的修改就是基于之前的老数据a了,而不是新数据b了，也许他面对数据b时的修改操作和面对数据a时的修改操作并不一样，这样他就被误导了，最后他丢失了a到b的更新。</p>
<p>解决办法可以通过悲观锁(假设这种并发更新是种大概率实践，先使用select…for update加锁，这样其他应用读取前必须等待)，或者乐观锁(使用版本号更新，比如last_modified_date,就是在数据库表格中加一列last_modified_date，就是最后更新的时间，每次更新的时候都将这列设成 systimestamp，当前系统时间，update时加上last_modified_date条件保证是上一次更新的时间，如果last_modified_date被修改过那么返回的update的结果就是更新了0条数据，然后选择刷新数据)</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务会把数据库从一种一致状态转换为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存了，要么所有修改都不保存。InnoDB存储引擎中的事务完全符合ACID(atomicity,consistency,isolation,durability)的特性。</p>
<ul>
<li><p><strong>原子性</strong>指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。</p>
</li>
<li><p><strong>一致性</strong>指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。例如，在表中有一个字段为姓名，为唯一约束，即在表中姓名不能重复。如果一个事务对姓名字段进行了修改，但是在事务提交或事务操作发生回滚后，表中的姓名变得非唯一了，这就破坏了事务的一致性要求，即事务将数据库从一种状态变为了一种不一致的状态。</p>
</li>
<li><p><strong>隔离性</strong>还有其他的称呼，如并发控制（concurrency control）、可串行化（serializability）、锁（locking）等。事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，通常这使用锁来实现。</p>
</li>
<li><p><strong>持久性</strong>,事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。需要注意的是，只能从事务本身的角度来保证结果的永久性。例如，在事务提交后，所有的变化都是永久的。即使当数据库因为崩溃而需要恢复时，也能保证恢复后提交的数据都不会丢失。但若不是数据库本身发生故障，而是一些外部的原因，如RAID卡损坏、自然灾害等原因导致数据库发生问题，那么所有提交的数据可能都会丢失。因此持久性保证事务系统的高可靠性（High Reliability），而不是高可用性（High Availability）。对于高可用性的实现，事务本身并不能保证，需要一些系统共同配合来完成。</p>
</li>
</ul>
<p>事务的分类：</p>
<ul>
<li><p><strong>扁平事务</strong>是最简单最频繁的一种事务，期间的操作是原子的，要么都执行要么都不执行，包括三种情况：成功完成(96%),应用程序要求停止事务rollback(3%),强制终止事务如超时(1%)。扁平事务的缺点是不能提交或回滚事务的某一部分，或分几个步骤提交。</p>
</li>
<li><p><strong>带有保存点的扁平事务</strong>，除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（Savepoint）用来通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。扁平事务中隐式的设置了一个保存点，即只能回滚到事务开始时的状态。</p>
</li>
<li><p><strong>链事务</strong>，在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样。链事务与带有保存点的扁平事务不同的是，带有保存点的扁平事务能回滚到任意正确的保存点。而链事务中的回滚仅限于当前事务，即只能恢复到最近一个的保存点。对于锁的处理，两者也不相同。链事务在执行COMMIT后即释放了当前事务所持有的锁，而带有保存点的扁平事务不影响迄今为止所持有的锁。</p>
</li>
<li><p><strong>嵌套事务</strong>是一个层次结构框架。由一个顶层事务控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务，其控制每一个局部的变换。</p>
</li>
<li><p><strong>分布式事务</strong>通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。比如跨行转账中涉及不同的后台数据库。</p>
</li>
</ul>
<p>对于InnoDB存储引擎来说，其支持扁平事务、带有保存点的事务、链事务、分布式事务。对于嵌套事务，其并不原生支持，因此，对有并行事务需求的用户来说，MySQL数据库或InnoDB存储引擎就显得无能为力了。然而用户仍可以通过带有保存点的事务来模拟串行的嵌套事务。</p>
<p>原子性、一致性、持久性通过数据库的redo log和undolog来完成。redo log称为重做日志，用来保证事务的原子性和持久性。undo log用来保证事务的一致性。有的DBA或许会认为undo是redo的逆过程，其实不然。redo和undo的作用都可以视为是一种恢复操作，redo恢复提交事务修改的页操作，而undo回滚行记录到某个特定版本。因此两者记录的内容不同，redo通常是物理日志，记录的是页的物理修改操作。undo是逻辑日志，根据每行记录进行记录。</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Huang Qingshan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://alifebug.github.io/2020/04/06/MySQL/">http://alifebug.github.io/2020/04/06/MySQL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ALifeBug.github.io">ALifeBug</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mysql/">Mysql    </a></div><div class="post_share"><div class="social-share" data-image="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.png"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/04/07/RSA%E7%AE%97%E6%B3%95/"><img class="prev_cover lozad" data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>RSA算法</span></div></a></div><div class="next-post pull-right"><a href="/2020/04/01/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/"><img class="next_cover lozad" data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>看透Spring MVC: 源代码分析与实践</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/12/20/Leetcode-SQL/" title="Leetcode-SQL"><img class="relatedPosts_cover lozad"data-src="https://s2.ax1x.com/2019/11/04/Kv8O6U.jpg"><div class="relatedPosts_title">Leetcode-SQL</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2021 By Huang Qingshan</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">简</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>